## VScode

### 快捷键

快速生成整个html框架:!+tab键
切换自动换行	Alt+Z
快速复制   Shift+Alt+⬇
快速生成大量随机英文字符   lorem
快速切换到标签外面的下一行   Ctrl+Enter

##### 插件快捷键

 快速加双标签   选中内容+Alt+W 再输入标签名

##### 快速生成语法

`div{1111}*3`

```html
<div>1111</div>
<div>1111</div>
<div>1111</div>
```



## html

##### 标题标签

HTML提供了`<h1>~<h6>`的标题标签，从1到6大小递减，每个标题独占一行，标题文字会加粗加大
##### 注释标签

 `<!-- 注释内容随便写 -->` 

注释的内容不会参与渲染，支持多行注释，类似于/* 注释内容 */
快捷键:Ctrl+/

##### 段落标签

`<p>段落</p>`
前后换行，段落间自动空行
浏览器宽度不够的时候自动换行
p标签中不能放任何的块元素

##### 换行标签

`<br>`
强制换行，单标签

##### 列表标签

> **无序列表**
>
> ```html
> <ul>
>     <li>山不在高，有仙则名</li>
>     <li>水不在深，有龙则灵</li>
>     <li>斯是陋室，为吾德馨</li>
> </ul>
> ```
>
> 快速生成框架:`ul>li*3`
> `<ul></ul>`:无序列表标签，内部只能嵌套`<li></li>`
> `<li></li>`列表项标签，内部可以放任意标签和内容
> **有序列表**
>
> ```html
> <ol>
>     <li>长江之水</li>
>     <li>黄河之水</li>
>     <li>珠江之水</li>
> </ol>
> ```
>
> **自定义列表**
>
> ```html
> <dl>
>     <dt>名词1</dt>
>     <dd>名词解释1</dd>
>     <dd>名词解释2</dd>
>     <dt>名词2</dt>
>     <dd>名词2解释1</dd>
>     <dd>名词2解释2</dd>
> </dl>
> ```
>
> 快速生成方式:	`dl>(dt+dd*2)*2`
> `<dl></dl>`:自定义列表标签，内部只能嵌套`<dt>`和`<dd>`标签

##### 图片标签

`<img src="dog.jpg">`
src属性：指定显示图片的路径
alt	文本	替换文本。图像不能显示时候显示的文字
title	文本	提示文本。鼠标放到图像上，显示的文字
width	像素	设置图像的宽度
height	像素	设置图像的高度
border	像素	设置图像的边框粗细

##### 音频标签

`<audio src="文件路径" controls></audio>`
controls属性用来控制是否显示控件和按钮	**这是一种无值属性**
autoplay	音频在就绪后立即播放，谷歌浏览器不支持，对于视频，若静音了，则可以实现静音自动播放
loop	当音频结束的时候重新开始播放
muted	规定输出应该被静音
preload	音频在页面加载时候进行加载，并预备播放。如果用了autoplay，则忽略该属性

```html
<!-- 音频标签2：兼容提示语法 -->
<audio controls>
	<source src="./song.mp3">
    <source src="./song.wav">
    您的浏览器不支持audio标签
</audio>
```

##### 视频标签

`<video src="mv.mp4" controls poster="poster.jpg"></video>`
poster	用来指定视频封面
对于视频更改宽高，若不合适，视频无法胡乱拉伸填充，只能等比例放大缩小

##### 超链接标签

`<a href="跳转目标" target="_blank">文本 或 图片</a>` 
target	用于指定链接页面的打开方式，其中_self为默认值，_blank为在新窗口中打开方式。
**当浏览器遇到它无法直接打开的链接路径时，就会提示用户下载**
不跳转仅保留端口	`<a href="#">我哪里也不想去</a>`

> `#` 表示特殊的链接地址，它实现在页面内空跳转
> `#` 跟上某个标签的id值，则直接跳转到 该标签处

可以设置`text-decoration: none;`来消除超链接的横线。

##### 符号实体

| 特殊字符 | 描述           | 字符的代码 |
| -------- | -------------- | ---------- |
|          | 空格符         | `&nbsp;`   |
| <        | 小于号         | `&lt;`     |
| >        | 大于号         | `&amp;`    |
| ￥       | 人民币         | `&yen;`    |
| &copy;   | 版权           | `&copy;`   |
| &reg;    | 注册商标       | `&reg;`    |
| &deg;    | 摄氏度         | `&deg;`    |
| &plusmn; | 正负号         | `&plusmn;` |
| &times;  | 乘号           | `&times;`  |
| &divide; | 除号           | `&divide;` |
| &sup2;   | 平方2(上标2)   | `&sup2;`   |
| &sup3;   | 立方3（上标3） | `&sup3;`   |

`&nbsp;`该空格占据宽度受 字体 影响明显而强烈。
`&emsp;`占据的宽度正好是一个中文宽度，且基本上不受字体影响。

##### 元数据标签

设置网页关键字
`<meta name="keywords" content="设定网页内容的关键字，有利于搜索引擎收录">`
设置网页内容描述
`<meta nema="description" content="设定网页内容的描述，有利于搜索引擎收录">`
设置网页重定向
`<meta http-equiv="refresh" content="3, url=http://web.itcast.cn"`
hettp-equiv	设置动作
3是倒计时秒数	再后面跟重定向的页面链接
一般用于在用户注册后，3秒种后自动跳转到首页
`<mate name="title" content="某某网站">`
设置搜索结果的超链接上的文字显示
`<html lang="语言代码">`

> 表示页面所使用的语言
> zh-CN	中文简体
> ja	日文
> en	英文
> 帮助搜索引擎的检索归类和浏览器的翻译功能

##### 表格

```html
<table>
    <tr>
    	<th>单元格内容</th>
        <th>单元格内容</th>
    </tr>
    <tr>
    	<td>单元格内容</td>
        <td>单元格内容</td>
    </tr>
</table>
```

table标签:定义表格，规定表格的范围
tr标签:定义表格行，必须包含在table标签中
td标签：定义单元格，必须包含在tr标签中
th标签：表头单元格标签，文本内容会加粗居中显示
thead标签：定义表格头（复杂的表格头可以有多行）
tbody标签：定义表格主体，主要用来包含数据（一个表格可以有多个表格主体）
tfoot标签：定义表格脚，主要用来包含统计数据（用的少）

> 三个表格结构标签的书写顺序，不会影响到显示的顺序
> 如果表格中没有写结构标签，浏览器会自动生成tbody标签

合并单元格:

> 语法：在单元格标签上写合并属性
> -跨行合并（纵向合并）：rowspan="要合并的单元格个数"
> -跨列合并（横向合并）：colspan="要合并的单元格个数"
> 目标单元格:
>
> > 概念：指合并属性所在的单元格
> > -跨行（纵向）：最上面的第一个单元格为目标单元格，添加rowspan属性
> > -跨列（横向）：最左边的第一个单元格为目标单元格，添加colspan属性
>
> 最后还要删除被合并的单元格

caption标签：表格描述信息标签，显示在表格最上面
##### 表单

**表单域：是一个包含表单元素的区域**
作用：可以将表单中包含的数据发送给服务器
语法:

```html
<form action="提交地址" method="提交方式" name="表单名">
    各种表单控件的HTML标签
</form>
```

常用属性:

| 属性        | 属性值   | 作用                                                         |
| ----------- | -------- | ------------------------------------------------------------ |
| action      | url地址  | 用于指定接收并处理表单数据的服务器程序的url地址。            |
| method      | get/post | 用于设置表单数据的提交方式，其取值为get或post。              |
| name        | 名称     | 用于指定表单的名称，以区分同一个页面中的多个表单域，必须设置，不设置就不发送数据给服务器 |
| placeholder | 提示信息 | 描述输入字段预期值的简短的提示信息显示在输入框，输入数据后自动消失。 |

**表单控件input:用于收集用户信息的控件标签，有很多种类型**
语法：`<input type="属性值">`

| 属性值   | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| button   | 定义可点击按钮（多数情况下，用于通过javaScript启动脚本）。   |
| checkbox | 定义复选框。                                                 |
| file     | 定义输入字段和"浏览"按钮，供文件上传。                       |
| hidden   | 定义隐藏的输入字段。这些用户看不到，但用来传递给服务器让服务器对表格做区分 |
| image    | 定义图像形式的提交按钮。                                     |
| password | 定义密码字段，该字段中的字符被掩码。                         |
| radio    | 定义单选按钮。                                               |
| reset    | 定义重置按钮。重置按钮会清楚表单中的所有数据。               |
| submit   | 定义提交按钮。提交按钮会把表单数据发送到服务器。该标签默认显示提交两个字，可以设置属性value=""隐藏 |
| text     | 定义单行的输入字段，用户可在其中输入文本，默认宽度为20个字符。 |

可以为单选按钮分组，通过设置name属性即可，若想点击文字就可以选中，加id属性并把文字放到lacel中:
```html
<input type="radio" name="gender" id="man">
<label for="man">男</label><!-- 这样点男这个字就能选中 -->
<input type="radio" name="gender"> 女
```

复选框也可以通过设置name属性来分组

| 属性        | 属性值       | 描述                                                         |
| ----------- | ------------ | ------------------------------------------------------------ |
| name        | 由用户自定义 | 定义input元素的名称。                                        |
| value       | 由用户自定义 | 规定input元素的值。                                          |
| checked     | checked      | 规定此input元素首次加载时应当被选中。checked与checked="checked"一样的效果 |
| maxlength   | 正整数       | 规定输入字段中的字符的最大长度                               |
| placeholder | 由用户自定义 | 为输入框设置提示文字                                         |
| disabled    | disabled     | 禁止用户操作控件，气死它。与checked一样可以简写字段。        |
| readonly    | redonly      | 禁止用户写 用在text文本框上，让用户怀疑键盘坏了。            |

for属性：点击label中的文本，相当于点击了id值与for值一样的输入框
```html
<lable for="boy">男
<input id="boy" type="checkbox" name="gender">
</lable>
```
**H5新增表单类型**

| 属性值         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| color          | 颜色选择的表单                                               |
| tel            | 唤起拨号表单，在pc端无效，手机端唤醒数字输入，实际也可以输入字符 |
| search         | 边框右边带叉号可以清空输入的内容的表格                       |
| range          | 滑动条表单 可以指定min="100" max="200" value="150" step="10" |
| number         | 数值表单 一个右边带上下箭头，只能输入数字的框 可以指定min="100" max="200" value="150" step="10" |
| email          | 限制用户输入的字段必须含有@符号                              |
| url            | 限制必须输入完整url:`https://www.baidu.com`                  |
| date           | 弹出选框，选择精确到天                                       |
| month          | 弹出选框，选择精确到月                                       |
| week           | 弹出选框，选择精确到周                                       |
| time           | 弹出选框，选择精确到分钟                                     |
| datetime-local | 选取本地时间 精确到分钟                                      |

**H5新增表单属性**

| 属性      | 属性值     | 描述                                                         |
| --------- | ---------- | ------------------------------------------------------------ |
| autofocus | autofocus  | 给文本框，选择框，或者按钮控件加上该属性，当打开页面时，该控件自动获得焦点，一个页面一个 |
| required  | required   | 验证输入不能为空                                             |
| multiple  | multiple   | 可以输入一个或多个值，每个值之间用逗号分开 email file select可用 |
| pattern   | 正则表达式 | 将属性值设为某个格式的正则表达式，在提交时会检查其内容是否复合给定格式 |



----

**表单控件select -下拉框：可以提供多个选择项给用户选择，节约页面空间**
语法：

```html
<select name="citys">
    <option value="">请选择</option>
    <option value="BJ">北京市</option>
    <option value="HB" selected>河北省</option>
</select>
```
select支持的属性：
    size:控制显示几个
    multiple:控制能否多选
option支持的属性：
	value:提供给后端需要用的value值
	selected:默认选中的值，类似checked

**多行文本，文本域**

```html
<textarea cols="10" rows="10" placeholder="请输入">这里是默认值</textare>
```

textarea的clos和rows控制中文不好控制，所以一般不用这两个属性，而是用css进行控制
这个文本域默认可以拖动右下角进行控制大小，可以通过css进行禁用

```css
textarea{
    width: 300px;
    height: 300px;/*控制大小*/
    resize: none;/*取消可以拖动改变大小*/
    /*取值 vertical horizontal both默认值 none*/
}
```

**字段集**
就是有个缺口的框框，可以用定位去实现。

```html
<fieldset>
    <legend>
        性别
    </legend>
    <div>
        框内的其他内容
    </div>
</fieldset>
```

legend用来放缺口的内容。整体样式都可以用css轻松控制。

**选项列表**  H5新增

input加一个list属性与datalist的id进行关联才可以
option必须写value，value的文字自动显示在下面的选项中
该选项列表若是写死的，还支持模糊搜索

```html
<body>
    <input type="text" list="mylist">
    <datalist id="mylist">
    	<option value="手机"></option>
        <option value="手表"></option>
        <option value="手环"></option>
        <option value="手镯"></option>
    </datalist>
</body>
```



---

##### 语义化标签

| 标签名     | 作用                                                         | display |
| ---------- | ------------------------------------------------------------ | ------- |
| header     | 头部                                                         | block   |
| section    | 独立区域 其他语义无法表达时选用                              | block   |
| aside      | 侧边栏(和主体相关的其他内容)                                 | block   |
| footer     | 脚部                                                         | block   |
| main       | 网页的主体部分（一个页面中只会有一个main）                   |         |
| nav        | 导航                                                         |         |
| article    | 独立的文章                                                   |         |
| div        | 没有语义 主要布局元素                                        | block   |
| span       | 没有任何语义 一般用于在网页中选中文字                        |         |
| figure     | 表示一段独立的流内容，使用figcaption元素为其添加标题（第一个或最后一个子元素的位置） |         |
| code       | 代表放代码，需要配合插件使用，自身无样式                     |         |
| cite       | 小段引用                                                     |         |
| blockquote | 大段引用                                                     |         |

##### 文章标记标签

| 标签名     | 作用                                      | display  |
| ---------- | ----------------------------------------- | -------- |
| small      | 缩小字体标签                              |          |
| i          | 斜体标签                                  |          |
| strong     | 表示强调 重要内容                         | 行内元素 |
| blockquote | 表示长引用 知乎上引用一段别的评论使用的多 | 块元素   |
| q          | 短引用                                    | 行内元素 |
| em         | 表示语气的加重                            | 行内元素 |
| pre        | 预格式化文本 保留空格，tab，回车          |          |
| center     | 居中显示                                  |          |
| sub        | 下标位置显示                              |          |
| sup        | 上标位置显示                              |          |
| del        | 删除                                      |          |
| s          | 错误的，也是一个删除线而已                |          |
| mark       | 马克笔标记，自带黄色背景                  |          |
| address    | 地址                                      |          |

##### 其他

`<hr>`单标签，实现一个横线分隔符
id属性：HTML标签的唯一标识（同一个页面上标签的id不要重复）
`<addr title="是一个优秀的后台开发语言">PHP</addr>`右边的效果是文本PHP样式上加一个虚点划线，鼠标hover显示title
`<progress value="60" max="100">60%<progress>`生成一个进度条，若不支持该标签则显示中间的60%文本

## css

#### 书写位置

##### 内联样式

也称为行内样式，嵌入式样式
示例：

```html
<body>
    <div style="width:200px; height:200px;">
        我是div
    </div>
</body>
```

##### 内部样式

```html
<style>
    div{
        color:yellow;
    }
</style>
```

##### 外部引入

```html
<!-- CSS外部引入方式1 -->
<link rel="stylesheet" type="text/css" href="css文件的路径"/>
<!-- css外部引入方式2 -->
<style type="text/css">
	@import url("css文件的路径");
</style>
```

> link和import之间的区别：
> 差别1：本质的差别：link属于XHTML标签，而@import完全是CSS提供的一种方式。
> 差别2：加载顺序的差别：当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显。
> 差别3：兼容性的差别：@import时CSS2.1提出的，所以老的浏览器不支持，@import只有IE5以上的才能识别，而link标签无此问题。

##### 优先级

越靠下，就听靠下的，后面的。也可以称为就近原则。不过因为三种样式的位置随便可以乱写，但默认用一样的写法，所以在这种统一的写法下可以称`!important>行内>内部>外部`。

### 选择器

#### 基础选择器

##### 标签选择器

```css
标签名{
    属性设置
}
```

##### 类选择器

通过class属性值来查找标签

```css
.类{
    属性设置
}
```

**类选择器的优先级问题:**

```html
<head>
    <style>
        .qianfeng{
            color:red;
        }
        .ibm{
            color:blue;
        }
        /*最终会是blue，这个和行内class="类选择器1，2"里面写的顺序无关，和这上一行两个类设置的上下顺序有关，最终按照就近原则*/
    </style>
</head>
<body>
    <div class="ibm qianfeng">
        测试类选择器的优先级
    </div>
</body>
```



##### id选择器

通过id属性值来查找标签
```css
#id值{
    属性设置
}
```

##### 通配符选择器

查找页面中所有标签
```css
*{
    属性设置
}
```

##### 后代选择器

`ul li{样式设置}`

##### 子代选择器

`ul>li{样式设置}`

##### 兄弟选择器

`.child+li{样式设置}`	选择.child元素后面第一个兄弟li
`.child~li{样式设置}`	选择.child元素后面所有的亲兄弟li

#### 组合选择器

##### 并集选择器

`p,li{样式设置}`
不限制选择器的种类，不同选择器中间用逗号隔开就可以了

##### 交集选择器

`li.err{样式设置}`
两个样式直接连写就可以了
#### 伪类选择器

伪类：同一个标签，根据不同状态，显示不同样式。
用于向某些选择器添加特殊的效果
概念：

- 静态伪类：只能用于 超链接标签
- 动态伪类：适用于 所有标签

##### 鼠标

作用：是根据鼠标的悬停状态为元素设置样式
语法：选择器:hover{设置样式}

```css
tr:hover{
    color: #fff;
}
```

##### 超链接

也称为动态选择器，因为hover可以应用在所有类型元素上
作用：为链接的不同访问状态设置不同的样式
语法：

| 选择器    | 功能                               |
| --------- | ---------------------------------- |
| :link     | 超链接被点击之前，超链接的初始状态 |
| :vistited | 超链接被点击过之后                 |
| :hover    | 悬停：鼠标悬停之时（未点击）       |
| :active   | 激活：鼠标点击标签之时（未松开时） |

注意：

- 这四个伪类选择器 必须 按照固定顺序书写：1.link -> 2.visited -> 3.hover -> 4.active
- 记忆方式：“爱恨准则”，LoVe HAte
- 若顺序不一致，不是完全失效，是会出现更特殊的特性
- 若交换hover和active的顺序（link->visited->active->hover)，因为点击的时候一定是会触发hover，这个机制导致hover的样式会覆盖active的样式，导致点击后不显示active的样式而是显示hover的样式。
- 为了简化代码，可以把伪类选择符中相同的声明提出来放在a选择符中；
  例如：a{color:red;} a:hover{color:green;} 表示超链接的初始和访问过后的状态一样，鼠标划过的状态和点击时的状态一样。

##### 焦点

:focus 伪类选择器 一般用在 表单元素 获取焦点时
代码：

```css
input:focus {
    border: 2px dashed #0094ff;
}
```

技巧：可以通过 鼠标点击 或 tab键 切换页面上 元素的焦点

##### 结构

作用：根据元素在文档中所处的位置，来动态选择元素，常用查找父级选择器中的子元素
好处：减少HTML文档对ID或类的依赖，有助于保持代码干净整洁

| 选择器             | 功能                                                         |
| ------------------ | ------------------------------------------------------------ |
| :first-child       | 当前父元素的第一个子标签元素                                 |
| :last-child        | 当前父元素的最后一个子标签元素                               |
| :nth-child(n)      | 当前父元素的指定第n个位置的子标签元素，索引值从1开始         |
| :nth-last-child(n) | 当前父元素的指定倒数第n个位置的子标签元素                    |
| :empty             | 选取没有子元素的标签，注意空格和换行也算子元素，必须两个标签紧挨着 |
| :only-child        | 只有一个孩子的盒子选中                                       |
| :root              | 匹配文档的根元素。在HTML中，根元素永远是html                 |

**注意事项**：

- 可以说使用父选择器，来指定查找子元素的搜索范围
- 伪类选择器去查找时，只查找规定类型的标签

nth-child(n)伪类选择器扩展

- 作用：选择某个父元素的一个或多个特定的子元素

- 用法：

  - n可以是数字，就是根据顺序选择第n个子元素（注意：序号从1开始）

  - n可以是关键字：even 偶数，odd 奇数

  - n可以是公式：常见公式如下

    | 公式 | 取值                             |
    | ---- | -------------------------------- |
    | 2n   | 偶数                             |
    | 2n+1 | 奇数                             |
    | 5n   | 5 10 15 ...                      |
    | n+5  | 从第五个开始（包含第五个）到最后 |
    | -n+5 | 前5个（包含第五个）              |

##### 目标

E:target 选择匹配E的所有元素，且匹配元素被相关URL指向，则选中。
使用该选择器实现的简易手风琴样式：

```html
<head>
    <style>
        div.content{
            display: none;/*默认隐藏*/
        }
        div.content:target{
            display: block;/*当点击链接时，触发目标选择器，然后显示，且其他因为失去选择而隐藏*/
        }
    </style>
</head>
<body>
    <div>
        <a href="#aaa">aaa</a>
        <div id="aaa" class="content">
            lorem...
        </div>
    </div>
    <div>
        <a href="#bbb">bbb</a>
        <div id="bbb" class="content">
            lorem...
        </div>
    </div>
</body>
```

##### UI元素状态

| 选择器     | 功能                                 |
| ---------- | ------------------------------------ |
| :enabled   | 匹配from表单类中处于可用状态的元素   |
| :disabled  | 匹配from表单类中处于不可用状态的元素 |
| :checked   | 匹配from表单类中处于选择状态的元素   |
| :selection | 匹配文本中被鼠标拖动选中的文本       |

给复选框加样式需要去掉默认样式
```css
input[type=checkbox]{
    appearance: none;
}
input:checked{
    background: red;
}
```



##### 其他

| 选择器       | 功能                       |
| ------------ | -------------------------- |
|              |                            |
| :not(选择器) | 选不符合括号中选择器的标签 |
#### 伪元素选择器

伪元素与伪类选择器写法不同的是，伪类选择器是一个: 而伪元素选择器标准写法是两个: 不过写成一个浏览器也认识

- ::before

  - 作用：

    - 创建一个伪元素，放到匹配的标签元素前面
    - 通过content样式属性 来为伪元素添加修饰性的内容

  - 示例：
    ```css
    <p class="msg">爱你哦，么么哒</p>
    .msg::before{
        content: '❤';
        color: #fff;
        backgroud-color: #0094ff;
        display: inline-block;
        width: 20px;
        text-align: center;
    }
    ```

  - 特点：

    - 伪元素默认为 行内元素
    - content 可以设置为图片 `content: url(love.jpg);`
    - 通过伪元素添加的内容无法和普通文章一样可以被鼠标拖动蓝底选中
    - 通过伪元素添加的内容无法在html中查看

- ::after

  - 作用：创建一个伪元素，放到匹配的标签元素后面
  - 其他与::before类似

- ::selection

  - 作用：设置被选中的文本部分的样式
  - 注意：只能设置背景颜色和字体颜色

- ::placeholder

  - 作用：设置input标签中placeholder属性值的样式

  - 示例：
    ```css
    <input type="text" placeholder="请输入用户名">
    input::placeholder {
        color:red;
        font-size: 14px;
    }
    ```

- ::first-letter

  - 选中第一个字符

  - 可以用来给文章第一个字大号显示
    ```css
    div::first-letter{
        font-size: 30px;
    }
    ```

- ::first-line

  - 选中文章的第一行

#### 属性选择器

- E[attr]:只要有属性就行，不要求属性值
- E[attr="value"]:指定属性名与属性值，且是全等，只能有这一个属性值
- E[attr~="value"]:指定属性名与属性值，这value是一个词列表，并以空格隔开，其中词列表中包含了一个value词，就可匹配上
- E[attr^="value"]:指定了属性名，且有value，属性值要求是以value开头的就能匹配上
- E[attr$="value"]:指定了属性名，且有value，属性值要求是以value结尾的就能匹配上
- E[attr*="value"]:指定了属性名，且有value，属性值要求包含value就能匹配上

示例:
```js
const checkboxes = document.querySelectorAll('.inbox input[type=checkbox]');
```



### 层叠性

概念：多个选择器应用到同一个元素时，各个选择器中不同的样式属性会叠加到一起应用到元素上
多类名场景：在标签的class属性中使用多个类目（多个类名间用空格分开）

#### 优先级 

概念：当多个选择器中的样式，作用于同一个元素时，相同样式属性可能出现不同的值
规则：

- 标签选择器<类选择器<id选择器<行内样式<!important
- 选择器优先级相同时，后面的优先级更高

| 选择器                  | 权重，CSS中用4位数字表示权重，权重的表达方式如：0，0，0，0 |
| ----------------------- | ---------------------------------------------------------- |
| 类型（元素）选择器      | 0001                                                       |
| Class选择器（类选择器） | 0010                                                       |
| id选择器                | 0100                                                       |
| 包含选择符              | 为包含选择符的权重之和                                     |
| 内联样式                | 1000                                                       |
| !important              | 10000                                                      |



#### 继承性

概念：父元素设置的CSS样式，会自动被应用到子元素
如果父元素和子元素样式有重复的，则子元素优先级更高

### 属性

#### 文本属性

- font-size 字体大小 单位是px，浏览器默认是16px，设计图常用字号是12px，比12xp更小的像素会被显示成12px

- font-family 字体 当字体中有空格时，需要加双引号；多个字体中间用逗号连接，先解析第1个字体，如果没有则解析第2个字体，依次类推。

- color 颜色 color:red; colr:#ff0; color:rgb(255,0,0);

- font-weight 加粗 100-900 100-细体-ligter 400-正常-normal 700-加粗-bold 900-更粗体-bolder

- font-style 倾斜 italic(斜体字)/oblique(倾斜的文字)/normal(常规显示)

- text-align 文本水平对齐 left,right,center,justify:水平两端对齐，但是只在多行起作用

- line-height 行高 line-height的数据=height的数据，可以实现单行文本垂直居中

- text-indent 首行缩进 text-indent可以取负值；text-index属性只对第一行起作用

- letter-spacing 字间距 控制文字和文字之间的间距

- word-spacing 词间距 控制英文词和英文词之间的间距

- text-decoration 文本修饰  :none没有/underline下划线/overline上划线/line-through删除线 这个属性用来删除超链接的下划线

- text-transfrom 控制英文文本大小写 capitalize 单词首字母大写 lowercase 所有字母小写 uppercase 所有字母大写 none 无

- font 文字简写 font是font-style font-weight font-size / line-height font-family 的简写。font:italic 800 30px/80px "宋体"；顺序不能改变，必须同时指定font-size和font-family属性时才起作用。

- white-sapce 空余空间 用来设置如何处理元素内的空白 
  normal默认值，空白会被浏览器忽略 
  nowrap文本不换行，文本会在同一行上继续，直到遇到`<br>`标签为止 
  pre显示空格，回车，不换行
  pre-wrap显示空格，回车，换行
  pre-line显示回车，不显示空格，换行
  
- text-overflow clip默认值，不显示省略号 ellipsis显示省略标记

- text-shadow 文本阴影
  ```css
  div{
  	text-shadow: 0px -10px 1px red,0px 10px 1px yellow;
      /*0px 是水平方向位移 -10px是垂直方向距离 1px是模糊程度 然后是颜色 可以写多个阴影用,隔开*/
  }
  ```

  

**经典效果**

- 当单行文本溢出显示省略号
  1. 设置容器宽度:`width:200px;`
  2. 强制文本在一行内显示:`white-space:nowrap;`
  3. 溢出内容为隐藏:`overflow:hidden;`
  4. 溢出文本显示省略号:`text-overflow:ellipsis;`

#### 列表属性

- list-style-type 定义列表符合样式 list-style-type: disc(实心圆)/circle(实心圆，默认值)/square(实心方块)/none(去掉符号，最常用)
- list-style-image 将图片设置为列表符合样式 list-style-image:url(图片路径);
- list-style-position 设置列表项标记的放置位置 list-style-position: outside(列表的外面，默认值)，inside(列表的里面)
- list-style 简写 list-style:none;（最常写的，用来去掉列表符合）这里上面三个属性随意组合着写。

#### 背景图片

- background-color 背景颜色

- background-image 背景图片 background-image:url(图片路径);

- background-repeat 背景图片的平铺 background-repeat: no-repeat(无重复)/repeat(x轴与y轴都重复，默认值)/repeat-x/repeat-y;

- background-position 背景图片的定位 background-position: 水平位置 垂直位置;  可以给负值
  1.20px -20px 按像素移动位置 2.10% -10% 按图片百分比移动位置 3.left center right top center bottom 按关键词定位

- background-size 背景图大小 1.400px 400px 讲图片强行拉伸到指定大小 2.100% 90% 按照墙的大小百分比强行拉伸图片 3.cover:把背景图片扩展至足够大，以使背景图片完全覆盖背景区域。会有一部分图片无法看到。 4.contaion:把图片图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。会铺不满盒子，留白。

- background-attachment 背景图片的固定 background-attachment: scroll(滚动，默认值)/fixed(固定，固定在浏览器窗口里面，固定之后就相对于浏览器窗口了);
  这个属性可以用来实现视差效果
  利用该属性实现固定的网页背景图片

  ```css
  body{
      background-image: url(背景图片路径);
      background-size: cover;
      background-attachment: fixed;
  }
  ```

  

- 可以简写成background
  除了background-size属性必须单独设置，其他属性都可以写在这个复合属性中，且除了position的x,y顺序，其他属性之间顺序随便调，有些属性可以不写，但会直接给默认值，就是说若想单设一个属性，要放在复合属性后面，在前面会被复合属性的默认属性覆盖。

#### 盒子模型

##### 内边距

`padding: 10px 20xp 30px 40px`
1个值：4个方向一致
2个值：上下，左右
3个值：上 左右  下
4个值：上 右 下 左 顺时针
背景色会自动蔓延到内边距
默认设置下，height,width不包含padding的大小，所以设置padding后，盒子大小变大
padding的值不可以取负数
若设置单一方向的padding值：padding-方向：top bottom left right

##### 边框

`border: 1px solid gray`
boder可以按照方向可以划分为boder-top/bottom/left/right
boder还可以划分为border-width/style/color
boder-style的样式有：solid实线 double双实线 dashed虚线 dotted点点线
背景色能蔓延到边框的空隙中

##### 外边距

`margin:0 auto;`
margin可以按照四个方向margin-top等进行设置
背景色不会蔓延到外边距
外边距可以使用负值
屏幕水平居中：`margin: 0 auto;`但不能用auto实现垂直居中，这个水平居中是响应式的居中

##### 特性问题

- 兄弟关系的两个盒子的外边距重合问题
  垂直方向，外边距重合，取最大值
  水平方向，外边距累加
- 父子关系的盒子，给子盒子加外边距，但作用到了父盒子的身上。
  - 删掉子盒子的外边距，改用父盒子的padding去挤子盒子，但要改父盒子的高度
  - 给父盒子设置上边框`border:1px solid transparents;`但会多一点边框
  - 给父盒子或子盒子加浮动，使两者不在一个维度
  - 给父盒子`overflow:hidden;`(值不为visible即可)，BFC 解决外边距塌陷问题

##### 怪异盒模型

属性：box-sizing 设置以特定方式定义宽高计算方式
属性值：
	content-box 默认值 正常盒子 宽高只计算content的
	border-box 怪异盒模型 宽高计算上boder padding content

### 文档流

#### 块级元素

上下排列 独占一行 容器级

>宽度默认为父元素的100%
>高度默认由内容撑起来
>宽高，内外边距都可以直接控制

#### 行内元素

有称为内联元素的
水平排列 默认从左到右，遇到障碍或宽度不够会自动换行 文本级

> 一般只放文本或其他行内元素
> 和相邻行内元素在一行，一行可以显示多个，行满后另起一行
> 不占有独立区域，只靠自身内容尺寸来支撑高宽
> 宽高 无法直接设置
> 内外边距 左右有效 上下无效

#### 行内块元素

> 特点：兼有行内元素和块级元素特点
>
> > *行内元素特点*
> > 和相邻行内元素在一行，中间由空白间隙
> > 一行可以显示多个，行满后另起一行
> > 宽高默认值就是它本身内容的宽高
>
> > *块级元素特点*
> > 宽高和内外边距可以控制

---
| 类型       | 标签                                                        |
| ---------- | ----------------------------------------------------------- |
| 块级别     | h1~h6，p，div，ul，li，ol，dl，dt，dd，table，form等        |
| 行内元素   | span，a，label，b，i，u，s，em，mark，code，small，strong等 |
| 行内块元素 | img，video，audio，input，button，select，textarea等        |

---
#### 显示模式的转换
语法:

```html
选择器{
	display: block | inline | inline-block;
}
```
display:none;与visibilty: hidden;的差别

> display:none; 不占位隐藏
> visibility: hidden; 占位隐藏

| 属性值       | 作用           |
| ------------ | -------------- |
| block        | 转成块级元素   |
| inline       | 转成行内元素   |
| inline-block | 转成行内块元素 |
| none         | 隐藏           |


---

#### 块级元素的特殊处理

##### 文本换行

- 规则:

  > - 中文，日文，韩文等遇到边界自动会换行
  > - 英文按照单词 会自动换行
  > - 英文炼狱长单词不会换行

- 处理:

  > - 文本内容多时，有时会需要强制换行
  >
  >   - 语法：
  >     ```html
  >     选择器{
  >     	word-break: break-all;
  >     }
  >     ```
  >
  > - 文本内容多时，有时会需要强制不换行
  >
  > - 语法：
  >   ```html
  >   选择器{
  >   	white-space: nowrap;
  >   }
  >   ```

##### 文本居中

设置line-height属性为盒子的高度

##### 溢出处理

- 自动换行
- 滚动条

语法:
```html
选择器{
	overflow: 属性值;
}
```

| 属性值  | 效果                                         |
| ------- | -------------------------------------------- |
| visible | 溢出部分正常显示(内容 超出 边界),默认值      |
| hidden  | 溢出部分隐藏                                 |
| scroll  | 溢出部分，用滚动条来显示                     |
| auto    | 溢出时，相当于scroll;未溢出时，相当于visible |
| inherit | 从父元素继承overflow属性的值                 |

overflow-x:hidden;  overflow-y:scroll; 可以使x轴y轴分别采用不同的两个溢出处理方式，两个属性要一起使用哦。
##### 外间距合并现象

文档流中，相邻 块级元素 上下外边距  会出现合并现象
##### 外边距塌陷

在文档流中块级元素的子盒子设置了外边距后，会产生子盒子外边距溢出父盒子的现象，称之为塌陷。
解决方案：

- 为父盒子 设置 border 属性
- 为父盒子 设置 overflow 属性（值不为visible）

#### 行内元素转换为块元素

- display:block;直接设置属性为块元素
- 给行内元素开始绝对定位absoluet
- 给行内元素开始浮动`float:left;`



### 浮动

作用：让 元素 脱离标准流，漂浮 到 标准流 上面；并能设置同行显示。
语法:

```html
选择器{
	float: 属性值;
}
```

属性值有：none,left,right。
浮动可以将三个div放到同一行并排显示，而用inline-block设置的三个div之间会自带一个空隙，浮动不会。
*inline-block块之间的小间隙，可以通过设置font-size为0来消除*

重点:

- 浮动元素 会 脱离标准流(脱标)，移动到 指定的位置。
- 浮动元素不再拥有原来的位置，位置会被 标准流 后i面 的元素 前移占据
- 浮动元素 会 一行内显示 并且 元素顶部对齐
- 浮动元素 会 具有行内块元素的特性（成行显示，可设置高宽）
- 文字 不识别 元素标签的浮动，所有会 围绕 浮动元素的 空出位置 进行布局
- 任何类型的元素 都可以浮动，浮动后都具有 行内块元素 特性;
- **注意**：浮动的元素，如果在前面，则可以正常显示，如果在 没有浮动元素后面，则会被后者排斥到下一行

1. 浮动后，标准流后的元素不补位

2. 父元素宽度不够时，内部的浮动子元素高度不一，可能卡住换行的浮动子元素

3. 父元素不设置高度，一旦子元素浮动，父元素高度将无法撑住
   

##### 支撑父元素的方法

> a) 给浮动的子元素添加兄弟div，给这个div设置高度
> b) 给这个div设置clear:both;清除浮动影响
> a,b方法都增加了一个元素，影响爬虫，代码可读性
> c) 给父元素设置overflow:hidden;原理是隐藏溢出的隐藏空间，构成封闭的空间，通过这个隐藏控件计算高度。
> c方法在导航栏一类需要子元素伸缩的情境下，因为hidden导致子元素无法在伸缩显示
> d)在浮动元素后面创建伪元素，用伪元素进行支撑
>
> ```css
> .box::after{
>     content: "";/*这里不用给内容，但要写这一行*/
>     clear: both;/*解决浮动带来的高度塌陷*/
>     width: 0;
>     height: 0;/*防止该元素影响布局*/
>     visibility: hidden;/*防止该元素显示影响显示效果，不过上面伪空字符串就可以不用写*/
> }
> ```
>
> 

浮动的作用

- 定义网页中其他文本如何环绕该元素显示
- 就是让竖着的东西横着来

##### 清除浮动

- 语法：
  ```html
  选择器{
  	clear: left|right|both|none;
  }
  ```

本质：清除浮动元素造成的影响，让其他元素认为浮动元素没有浮起来
这个left，right不是管浮动元素在塌陷元素的左右，而是看浮动元素的float设置的值

- 清除浮动方式:
  1. 给被遮挡元素使用clear属性，解决 前两个场景 问题
  2. 给浮动元素的容器使用overflow属性，解决 父盒子 丢失高度问题  启动BFC，让容器计算高度
  2. 直接给浮动元素的容器加一个固定高度

### 字体

##### 字体类型

- 衬线字体（serif）
  - 特征：文字笔画粗细不均，开始和结尾有额外装饰
  - 优势：
    - 字号较小 时更容易分辨
    - 比较适合应用于大段落文字
    - 在报刊书籍中应用比较广泛
- 无衬线字体（sans-serif）
  - 特征：文字笔画粗细均匀，但首尾无装饰
  - 优势：
    - 相对于衬线字体更具美感
    - 在电子屏幕中同等字号显得要大
    - 目前网页中大多采用无衬线字体（微软雅黑）
- 等宽字体（monospace）
  - 特征：单个字母或文字的宽度相等
  - 优势：
    - 由于等宽字体文字的宽度相等，便于处理文字的对齐
    - 一般用于程序代码的编写
    - 一般用Consolas-数字0有斜杠

##### 字体引入

@font-face是CSS3中的一个模块，它主要是把自己定义的Web字体嵌入到你的网页中，随着@font-face模块的出现，我们再Web的开发中使用字体不怕只能使用Web安全字体（@font-face这个功能早在IE4就支持）
@font-face的语法规则：

```css
@font-face{
    font-family:<YourWebFontName>;
    src:<source>[<format>][,<source>[<format>]]*;
    [font-weight:<weight>;]
    [font-style:<style>];
}
```

@font-face语法说明：
YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-famil。如"font-family:"YourWebFontName";
source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝对路径；

---

系统字体

- 操作系统中可以为每种 字体类型 设置 默认字体
- Windows 系统字体
  - 宋体（SimSun）默认的有衬线字体
  - 微软雅黑（Microsoft Yahei）默认的无衬线字体
  - Arial 只针对英文的无衬线字体
- Mac OS 系统字体
  - 黑体-简（Heiti SC）默认的有衬线字体
  - 苹方（PingFang SC）默认的无衬线字体
  - Helvetica 只针对英文的无衬线字体

### 背景图片

将背景图片设置为填充背景状态:
```html
选择器{
	backgroud-img: url(路径);
	backgroud-repeat: no-repeat;
	backgroud-size: cover;
}
```

backgroud-size的参数：

| 参数值   | 举例      | 说明                                               |
| -------- | --------- | -------------------------------------------------- |
| 宽高数值 | 10px 20px | 设置背景图宽高，如果只设置一个，另一个为auto       |
| 百分比   | 5% 10%    | 以元素百分比来设置高宽                             |
| cover    | cover     | 背景图片覆盖元素区域，可能出现图片某些部分超出元素 |
| contain  | contain   | 把图片扩展至最大尺寸，使宽高完全适应元素区域       |

---
背景图片定位到中心：

```css
选择器{
    backgroud-image: url(路径);
    backgroud-repeat: no-repeat;
    backgroud-position: center center;
}
```

bcakgroud-position的参数设置：

| 参数值 | 举例      | 说明                                     |
| ------ | --------- | ---------------------------------------- |
| x,y    | 10px 20px | 设置x和y坐标位置                         |
| p1,p2  | center    | top\|center\|bottom，left\|center\|right |

---

背景附着（背景图固定）

- 作用：设置背景图 是否 跟随滚动

- 语法：
  ```css
  选择器{
      background-image: url(路径);
      background-attachment: 属性值;
  }
  ```

  | 参数   | 作用                     |
  | ------ | ------------------------ |
  | scroll | 背景图像时随对象内容滚动 |
  | fixed  | 背景图像固定             |

---

background-clip
设置元素的背景（背景图片或颜色）是否延伸到边框，内边距盒子，内容盒子下面。

精灵图
概念：精灵图（雪碧图）是一种包含若干小图片的大图片
背景图位置技巧：

- X轴 正数往右，负数往左
- Y轴整数往下，负数往上

### 元素装饰

#### 圆角

通过 border-radius 为盒子设置圆角弧度
语法：`border-radius: 10px;`
border-radius支持1-4个多值设置大小
支持px和百分比
设置单个角的圆角有以下属性：

```css
div{
    boder-top-left-radius: 10px;
    boder-top-right-radius: 10px;
    boder-bottom-left-radius: 10px;
    boder-bottom-right-radius: 10px;/*必须先写垂直方向，再写水平方向*/
}
```

还有这种写法：`border-radius: 30px/60px;`
30px/60px 水平/垂直  只支持boder-radius属性，那四个指定角的不能这么写
还可以写成：`boder-radius: 10px 20px 30px 40px/50px 60px 70px;`从而使各个角不一样
要想把正方形变成正圆，则需要`border-radius: 50%;`这个50%是整个盒子，包含内边距，边框等设置的才园。
若值大于50%效果一样不会变化。
**案例**

- 半圆形：
  ```css
  div{
      width: 100px;
      height: 50px;/*宽高必须是1:2的长方形*/
      background: green;
      margin:0 auto;
      bnorder-radius: 50px 50px 0 0;
  }
  ```

  

#### 阴影-盒子阴影

通过 box-shadow 为盒子设置阴影效果
语法：`box-shadow: 50px 50px 50px #ccc inset;`
属性值：

| 参数               | 作用                                              |
| ------------------ | ------------------------------------------------- |
| 第1个参数 h-shadow | 水平偏移量，正值向右，负值向左 必需的             |
| 第2个参数 v-shadow | 垂直偏移量，正值向下，负值向上 必需的             |
| 第3个参数 blur     | 模糊度，值越大越模糊，不可以为负数 可选的         |
| 第4个参数 spread   | 阴影收缩，正值阴影扩大，负值阴影缩小 一般为0 可选 |
| 第五个参数 color   | 阴影颜色 可选                                     |
| inset              | 指定阴影类型为内阴影 可选                         |

#### 阴影-文字阴影

通过 text-shadow 为文字设置阴影效果
语法：`text-shadow: 5px 5px 5px #ccc`
属性值：

| 参数      | 作用                                         |
| --------- | -------------------------------------------- |
| 第1个参数 | 水平偏移量，正值向右，负值向左               |
| 第2个参数 | 垂直偏移量，正值向下，负值向上               |
| 第3个参数 | 模糊度，值越大越模糊，不可以为负数 一般不为0 |
| 第4个参数 | 阴影颜色                                     |

#### 透明

- **opacity**
  语法：`opacity: 0.3;`
  注意：

  - 盒子与所有子元素都会被设置为透明效果
  - 透明度取值0~1(小数时，推荐省略0)如：`opacity: .3;`

- **rgba**
  语法：`background-color: rgba(37, 169, 245, .3);`

- **transparent**
  transparent 可以看成是一种纯透明的颜色值
  transparent=rgba(0,0,0,0)
  语法：‘background-color: transparent;’
  注意：
  
  - 可以用在所有颜色处：字体色，背景色，边框色等
  
  - 作为特殊颜色值，相当于rgba(0,0,0,0)-纯黑透明
  
    补充：使用transpanrent完成三角箭头
    ```css
    .box{
        border-width: 50px;
        border-style: solid;
        border-color: transparent transparent transparent red;
    }
    ```

#### 动画

##### 过渡效果

- 过渡时长
  - 是指样式从一种状态变成另外一种状态所持续的时长，以s(秒)为单位，支持小数
  - 语法：`transition: all/一个具体属性值 运动时间s/ms 延迟时间s/ms 动画类型`
    `transition-duration:1s;`
  
- 过渡延时

  - 是指延迟执行样式的变化，同样以秒为单位

  - 语法：
    ```css
    transition-duration: 1s;
    transition-delay: 3s;
    ```

  - 作用：等3秒后，再开始过渡效果

  - 注意：鼠标移入后3秒开始执行动画，同样鼠标移开也是要等3秒才收缩

- 过渡属性

  - 可以只当针对某个样式属性（默认是针对所有改变的样式属性都生效）
  - 语法：`transition-property: 属性1 , 属性2;`
  - 可以是all

- 过渡曲线

  - 指过渡效果执行过程中速度变化的曲线

  - 语法：`transition-timming-function: 属性值;`

  - 部分内置速度曲线：

    | 值             | 描述                                                         |
    | -------------- | ------------------------------------------------------------ |
    | linear         | 规定以相同速度开始至结束的过渡效果 (0.0, 0.0, 1.0, 1.0)      |
    | ease(默认)     | 规定慢速开始，然后变快，然后慢速结束的过渡效果 (0.25, 0.1, 0.25, 1.0) |
    | ease-in        | 规定以慢速开始的过渡效果 (0.42, 0, 1.0, 1.0)                 |
    | ease-out       | 规定以慢速结束的过渡效果 (0, 0, 0.58, 1.0)                   |
    | ease-in-out    | 规定以慢速开始和结束的过渡效果 (0.42, 0, 0.58, 1.0)          |
    | cubic-bezier() | 贝塞尔曲线网站：https://cubic-bezier.com                     |

- 复合属性

  - 语法：
    `transition: 过渡时长;`
    `transition: 过渡时长 过渡延时`
    `transition: 过渡时长 过渡延时 过渡曲线`
    `transition: 过渡属性 过渡延时 过渡曲线`
  - 注意：
    - 默认对所有样式属性都应用过渡效果(all)
    - 设置过渡时。除过渡时长不能省略，其他都能省略
    - 设置过渡时，除过渡延时必须再过渡时长之后，其他没有顺序要求

- 注意：

  - 部分样式属性不支持过渡效果，如：position，z-index，diaplay
    display:none->block动画替代方案
  
    ```css
    div ul{
        /*display: none;*/
        margin-top:50px;
        transition: all 1s;
        height: 0px;
        overfilow: hidden;/*虽然ul已经是高度0了，但li还是会挤出来，所以设置溢出隐藏*/
    }
    div:hover ul{
        /*diaply: block;*/
        height: 200px;
    }
    ```
  
  - ==
  
- 逐帧动画：`transition-timing-function:steps(动画执行的步数);`

- 动画启动中心点： transform-origin: left top;

##### 旋转

`rotate(-80deg)`
旋转ratate()函数通过指定的角度参数对元素根据对象原点指定一个2D旋转。
正数顺时针转，负数逆时针。
rotateX(80deg) 元素绕X轴像纸片一样转
rotateY(90deg) 元素绕Y轴转
ratateZ(90def) 和roate()一样的效果

##### 2D移动

该属性将元素向指定的方向移动，类似于position中的relative。
reanslate(x, y)  x,y可以去负值 -px或-100%
translateX(x) 只控制x轴移动
translateY(y) 只控制y轴移动
示例:

```css
/*transfrom: translateX(x);
transfrom: translateY(y);*/
/*上面的写法是错的，后面的设置会覆盖前面的设置*/
transfrom: transalteX(x), translateY(y);
```

设置left等属性会频繁的造成浏览器回流重排，而transform和opacity属性不会，因为它是作为合成图层发送到GPU上，有显卡执行的渲染，这样做的优化如下

- 可以通过亚像素精度得到一个运行在特殊优化过的单位图形任务上的平滑动画，并且运行非常块。
- 动画不再绑定到CPU重排，而是通过GPU合成图像。即使运行一个非常复杂的JavaScript任务，动画仍然会很快运行。

###### 应用示例

```css
.sun{
    position: absolute;
    top:50%;
    left: 50%;/*这里的50%是相对父级（全屏），然后左上角现在定位到屏幕中心，需要回移*/
    transform: translate(-50%, -50%)/*这里的50%是相对这个元素自己的宽高进行移动的*/
}
```



##### 2D缩放

`scale(1.5);/*中心放大1.5倍*/`
让元素根据中心远点对对象进行缩放。默认值为1，小于一缩小，大于一放大。若是负值则是倒像放大缩小。
该属性可以接收一个值或两个值，一个值则默认第二值等于第一个值，第一个值控制X轴，第二个值控制Y轴
还有scaleX和scaleY两个属性对XY轴单独控制
该属性一般给父盒子增加`overflow:hidden;`防止放大影响其他元素显示。

##### 复合动画

写成`transform: translateX(400px) scale(0.5);`从而做到既位移又旋转
但是要注意最好把位移写在最前面

```css
.box div:nth-child(2){
    transform: translateX(400px) scale(0.5);
}
.box div:nth-child(3){
    transform: scale(0.5) translateX(400px);
}
/*上面两个动画的最终位置并不一样，因为第三个先缩小了，所有把400px的位移距离也缩小了，因此距离移动短*/
.box div:nth-child(4){
    transform: translateX(400px) rotate(45px);
}
.box div:nth-child(5){
    transform: rotate(45px) translateX(400px);
}
/*4和5也不一样，因为5旋转了X轴，导致是向斜下方前进了400px*/
```

##### 倾斜

`transform: skew(30deg,30deg);`
倾斜skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。
一个参数时：表示水平方向的倾斜角度；
两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度
skewX(30deg) 该函数只拉伸X轴 正值-拽右下角，往右边拉动，形成30deg 负值-拽左下角，往左边拉动，形成30deg
skewY(30deg) 该函数只拉伸Y轴 正值-拽右下角，往下拉动，形成30deg 负值-拽左上角，往上拉动，形成30deg

##### 关键帧动画

animation和transition的区别：

- 相同点：
  都是随着时间改变元素的属性值。
- 不同点：
  transition需要触发一个时间（hover时间或click事件等）才会随时间改变其css属性；而animation在不需要触发任何事件的情况下也可以显式的随着时间变化来改变元素css的属性值，从而达到一种动画的效果，css3的animation就需要明确的动画属性值。

`animation: mymove 20s ease-in-out 2s infinite alernate;`
animation: 动画名称 一次动画持续时间 动画动作函数 动画延迟时间 动画循环次数 动画在循环中是否反向运动
动画名称是由@keyframes关键字定义的

>```css
>@keyframe name{
>    from{
>        样式；
>    }
>    to{
>        样式;
>    }
>}
>```
>
>还可以用百分比区分动画帧
>```css
>@keyframe name2{
>    0%{
>        样式；
>    }
>    50%{
>        样式;
>    }
>    100%{
>        样式;
>    }
>}
>```

动画循环次数可以是数字，也可以是`infinite`，表示无限循环
animation这个复合属性的单独属性：

- animation-name 检索或设置对象所应用的动画名称
- animation-duration 检索或设置对象动画的持续时间
- animation-timing-function 检索或设置对象动画的过渡类型
- animation-delay 检索或设置对象动画延迟的时间
- animation-iteration-count 检索或设置对象动画的循环次数
- animation-direction 检索或设置对象动画在循环中是否反向运动
  normal：正常方向
  reverse：反方向运行 抽屉动画经常使用
  alternate：动画先正常运行再反方向运行，并持续交替运行
  alternate-reverse：动画先反运行再正方向运行，并持续交替运行
- animation-play-state 检索或设置对象动画的状态
  running：运动
  paused：暂停
  一半应用到鼠标经过时动画停止，鼠标移开动画继续执行

##### 逐帧动画

当有逐帧的图片素材时，不能使用自带的补帧方案，因此放弃补帧，使用steps参数，控制图像显示补帧
steps(1,start);
end 保留当前帧，看不到最后一帧，动画结束
start 保留下一帧，看不到第一帧，从第一帧很快跳到最后一帧

##### 动画库

https://www.dowebok.com/demo/2014/98/

##### 3D动画

首先要打开3D效果
`transform-style: preserve-3d;`  这个属性的默认值只flat，是2D效果

- 3D位移

  - 3D沿Z轴位移会出现景深效果

  - translateZ()

  - translate3d()

  - 景深
    >近大远小
    >程序中实现的方法 perspective: 视线距离
    >在父元素中使用： `perspective: 1200px;`
    >在子元素中使用： `transform: perspective(1200px);`
    >上面两个都设置会发生冲突，建议只设置父元素，通常的数值在900-1200之间
    >指定视线角度：‘perspective-origin: center center’
    >还可以填写`perspective-origin: 100% 100%`

- 3D旋转

  - rotateX()
    `rotateX(30deg)`
  - rotateY()
  - rotateZ()
    这个就是转当前平面，3D效果几乎无
  - ratate3d()
    ratate3d(1,1,1,30deg); 表示沿X，Y，Z都转30度

- 3D缩放

  - scaleZ()
    这个参数里面填数字，1为原比例，然后还有配合景深，再加缩放或旋转才能感觉出来变化
  - scale3d()
    括号里面填写3个数字，分别代表X，Y，Z轴的放大倍数

#### 渐变

##### 线性渐变

语法： `background: linear-gradient([direction,] color-stop1, cplpr-stop2, ...);`
direction 默认为`to bottom`，即从上向下渐变
stop 颜色的分别位置，默认均匀分别，例如有三个颜色，各个颜色的stop均为33.33%
支持多颜色，颜色直接在后面一直加就行
支持写方向 to left,tobottom,to right,to top, to bottom right...
支持角度写法，就是第一个参数写成`90deg`就是90度
每个颜色后面还可以加百分比，来控制颜色的起止位置

##### 径向渐变

径向渐变不同于线性渐变，线性渐变是从“一个方向”向“另一个方向”的颜色渐变，而径向渐变是从“一个点”向四周的颜色渐变
语法：`background: radial-gradient([center,][shape,][size,]start-color,...,last-color);`
center: 渐变起点的位置，可以为百分比，默认是图形的正中心
shape: 渐变的形状，ellipse表示椭圆形，circle表示圆形。默认为ellipse，如果元素形状为正方形的元素，则ellipse和circle显示一样。
size: 渐变的大小，即渐变到哪里停止，它有四个值。

> closest-side 最近边
> farthest-side 最远边
> closest-corner 最近角
> farthest-corner 最远角

该属性兼容性很不好，很可能需需要将该属性写成`-webkit-radial-gradient(...);`
##### 重复渐变

重复渐变的属性就是在线性渐变和径向渐变的属性前面加一个`repeating-`前缀

- 重复线性渐变
  `div{background: repeating-line-gradient(red,yellow 10%,green 20%);}`
  说明：10%的位置为yellow，20%的位置为green，然后按照这个20%向下重复
- 重复径向渐变
  `div{background: repeating-radial-gradient(red,yellow 10%,green 20%);}`


#### 经典样式

- 导航文字右边放一个三角箭头上下指
  ```css
  .box{
      width: 100px;
      line-height: 50px;/*存放导航文字的盒子*/
  	text-indext: 20px;/*向左缩进一段距离留给三角形*/
  	background: blue;
  	color: white;/*字体颜色*/
  }
  span{
      display: inline-block;/*切换为行内块，就能指定宽度和高度了，并能放在导航文字后面*/
      border: 5px solid transparent;
      border-top: 5px solid black;/*设置三角形*/
      position: relative;/*设置相对定位讲三角形移至中心位置*/
      top: 2.5px;
  }
  .boxLhover span{
      border: 5px solid transparent;
      border-bottom: 5px solid black;
      top: -2.5px;
  }
  ```

### 元素定位

- 所谓定位就是按照某种方式来摆放盒子
  定位 = 定位类型 + 偏移量

- 定位类型

  | 属性值   | 语义     | 文档流 | 偏移位置                                                     |
  | -------- | -------- | ------ | ------------------------------------------------------------ |
  | static   | 静态定位 | 默认值 | 默认                                                         |
  | relative | 相对定位 | 不脱离 | 自己初始的位置                                               |
  | absolute | 绝对定位 | 脱离   | A）当没有父元素或者父元素没有定位，参照物使浏览器窗口的第一屏 B)有父元素且父元素有定位，以父元素的padding边为参照物 |
  | fixed    | 固定定位 | 脱离   | 浏览器的当前位置                                             |
  | sticky   | 粘性定位 | 吸顶   |                                                              |

- 偏移量

  四个： left right top bottom
  注意：使用时不需要四个都写上
  
- 特性
  img与p标签属于不同的类型，因此去除掉margin和padding的影响后，因为类型不同，两者上下会有3像素的空间，这时候应把img转换为block类型，就去除了这3像素的空隙

- z-index层叠顺序
  z-index属性是不带单位的，并且可以给负值，没有设置z-index时，最后写的对象优先显示在上层，设置后，数值越大，层越靠上。
  使用z-index必须开启定位

---

##### 静态定位

  - 默认使用
  - 无任何偏移
 ##### 相对定位

  - 元素相对于**原来位置**进行偏移。
  - 特点：
    - 相对于原来位置，与父容器无关
    - 相对定位不脱离文档流，位移后原来的位置仍被当前元素占有。
    - 如果相对方向同时设置，则left和top优先。

##### 绝对定位

  - 定义：相对离自己最近已定位的祖先元素（定位方式不是静态定位）进行偏移

  - 语法：
    ```css
    position: absolute;
    top: 30px;
    left: 20px;
    ```

  - 特点：

    - 相对于离自己最近定位祖元素的位置
    - 所有祖元组都未定位时，参考浏览器窗口进行偏移
    - 绝对定位会脱离文档流，原来位置不再占有
    - 默认位置不变
    - 由于相对定位未脱离文档流，所以绝对定位通常配合相对定位使用。
    
  - 绝对定位与浮动的区别：
    float:半脱离，文字环绕
    absolute:全脱离，不会出现文字环绕效果

 ##### 固定定位

  - 定义：相对于浏览器窗口进行偏移
  - 特点
    - 会脱离文档流，位置移动后原来位置不再占有。
    - 默认位置未自身原来位置
    - 如果相对方向同时设置，则left和top优先。

 ##### 粘性定位

sticky --> 可以用js实现该功能

  - 定义：可以看成相对定位和固定定位的结合
  - 特点
    - 需要设置 偏移量(top,bottom等)才有效果
    - 偏移量可以是负值，然后回让该元素缺一部分显示
    - 以最近的具有滚动条的祖元素作为唯一参考
    - 不会脱离文档流，原位置不会被占据
    - 当滚动条没有到达元素时，元素显示再原地
    - 当滚动条到达元素时，元素立即会变成绝对定位，按照偏移量显示在固定的位置，不受滚动条的影响
    - 使用 top 时当浏览器有上自下滚动时有效果，定位：定在上方
    - 使用bottom是当浏览器 由下向上滚动有效果，定位：定在下方

 ##### 定位层叠 z-index

  - 解决：多个元素如果定位重合，可以通过z-index调整层次
  - 语法： `z-index:数值;`
  - 特点：
    - z-index 数值越大，层级越高，可以是负值
    - z-index 只针对定位元素生效
    - 默认情况，书写顺序靠后的层级高于靠前的

---

 ### 应用案例

##### 自适应大小

- 如果子元素想根据父元素的宽高来自适应调整自己的宽高
  
- 方案：使用绝对定位，同时设置left和right，top和bottom，可实现相对父元素的自适应布局。一个重要的前提是不要为盒子指定width或height
  
- 代码示例：
```css
.box{
    width: 300px;
    height: 200px;
    background-color: #0094ff;
    position: relative;
}
.inner{
    background-color: darkred;
    position: absolute;
    top: 40px;
    bottom: 40px;
    left: 20px;
    right: 20px;
}
```

##### 子绝父相

- 定义： 子盒子是绝对定位的话，父盒子最好用相对定位
- 好处：滋贺子绝对定位，不占位置，可以放到父盒子的任何一个地方，不影响其他兄弟盒子
- 关于父盒子：
      父盒子需要加定位来限制子盒子在父盒子内显示
      另外，父盒子布局时需要占据位置，所以父盒子只能是相对定位
- **子绝父相绝对定位z-index问题**
      当子绝父相的两个盒子开启绝对定位后，默认父元素在下，若想提高父元素的层级，给父元素加z-index无效，需要给子元素加z-index:-1（负值就行），可能是因为子元素自动继承父元素层级导致的。

##### 放盒子至屏幕中心

```css
div{
    width: 200px;
    height: 200px;
    background: yellow;
    position: absolute;/*开启绝对定位进行移动*/
    top: 50%;
    left: 50%;/*讲元素的左上角定位至中心*/
    margin-left: -100px;
    margin-top: -100px;/*讲元素往左上回移动一半*/
}
```

##### 子盒子定位父盒子中心

```css
.father{
    width: 500px;
    height: 500px;
    background: yellow;
    margin: 0 auto;
    position: relative;/*开启子绝父相，使子元素方便定位移动*/
}
.child{
    width: 200px;
    height: 200px;
    background: red;
    position: absolute;/*下面的定位原理与盒子放到屏幕中心的原理一样*/
    top:50%;
    left:50%;
    margin-left:-100px;
    margin-top: -100px;
}
```

##### 中间内容区变长

使用min-height属性，指定最小高度来支撑，同时又没有写死height可以自动撑开内容区。

##### 高度自适应

因为body的默认高度样式伪0，所以要专门设置一下body的高度为100%，其他的元素才能高度自适应
```css
*{
    margin: 0;
    padding 0;
}
.box{
    width: 100%;
    height: 100%;
    background: yellow;
}
/*若只写上面的代码，则box不会全部铺满，而是宽度为屏幕宽度，高度继承body的默认高度0*/
html,body{
    height: 100%;/*这样将body的高度改为屏幕的高度*/
}
```

### 布局

##### 两栏布局

整个页面分为左右两个盒子，左边盒子固定宽度，占据左边当作导航栏，右边内容区宽度自适应占据右边

- 通过div的自动占据正行机制实现
  ```css
  *{
      margin: 0;
      padding 0;
  }
  html,body{
      height: 100%;
  }
  .left{
      width: 200px;
      height: 100%; /*占据整个左边*/
      background: red;
      float: left;/*通过浮动让另一个div从下面上来*/
  }
  .right{
      height: 100%;/*占据整个右边的高度*/
      /*width不写，利用div的特性占据整个剩下的页面*/
      background: yellow;
      margin-left: 200px;/*通过设置左外边距给左侧空开位置*/
  }
  ```

- 通过calc()函数实现
  ```css
  *{
      margin: 0;
      padding 0;
  }
  html,body{
      height: 100%;
  }
  .left{
      width: 200px;
      height: 100%;
      background: red;
      float: left;
  }
  /*整体布局逻辑与上面一样，就改了一下width不再是利用div的特性，而是函数计算*/
  .right{
      height: 100%;
      width: calc(100% - 200px);/*该函数也是动态实时计算的*/
      background: yellow;
      margin-left: 200px;
  }
  ```

##### 三栏布局

类似两栏布局，三栏布局是左右两边的盒子固定宽度，中间的盒子宽度动态改变。

- 通过三个盒子挤在一起实现
  ```html
  <!DOCTYPE html>
  <html lang="en">
      <head>
          <meta charset="UTF-8" />
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Document</title>
          <style>
              * {
                  margin: 0;
                  padding: 0;
              }
              html,
              body {
                  height: 100%;
              }
              .left,
              .right {
                  width: 200px;
                  height: 100%;
              }
              .left {
                  background-color: yellow;
                  float: left;
              }
              .right {
                  background-color: red;
                  /* float: left; */
                  float: right;
              }
              .center {
                  height: 100%;
                  background-color: blue;
                  margin-left: 200px;
                  margin-right: 200px;
                  /*float: left;*/
              }
          </style>
      </head>
      <body>
          <div class="left"></div>
          <div class="right"></div>
          <!--这里顺序必须是右边栏在前面先向右浮动，若是将center放在上面，center会因为div的特性讲右边占据，不过将center放在中间后，三个一起向右浮动也不行，中间盒子因为浮动脱离标准流，导致宽度变成0，似乎想要把center放在中间只能用函数计算宽度 -->
          <div class="center"></div>
      </body>
  </html>
  ```

- 通过函数计算宽度
  ```css
  <!DOCTYPE html>
  <html lang="en">
      <head>
          <meta charset="UTF-8" />
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Document</title>
          <style>
              * {
                  margin: 0;
                  padding: 0;
              }
              html,
              body {
                  height: 100%;
              }
              .left,
              .right {
                  width: 200px;
                  height: 100%;
              }
              .left {
                  background-color: yellow;
                  float: left;
              }
              .right {
                  background-color: red;
                  float: left;
                  /* float: right; */
              }
              .center {
                  width: calc(100% - 400px);
                  height: 100%;
                  background-color: blue;
                  /* margin-left: 200px; *//*三个容器通过float挤在一起*/
                  /* margin-right: 200px; */
                  float: left;
              }
          </style>
      </head>
      <body>
          <div class="left"></div>
          <div class="center"></div>
          <div class="right"></div>
      </body>
  </html>
  
  ```

- 通过flex弹性盒子也可以轻松设置三栏布局
  ```html
  <!DOCTYPE html>
  <html lang="en">
      <head>
          <meta charset="UTF-8" />
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Document</title>
          <style>
              * {
                  margin: 0;
                  padding: 0;
              }
              html,
              body {
                  height: 100%;
              }
              body{
                  display: flex;
              }
              .left,
              .right {
                  width: 200px;
                  background: gray;
              }
              .center{
                  flex: 1;
                  background: yellow;
              }
          </style>
      </head>
      <body>
          <div class="left"></div>
          <div class="center"></div>
          <div class="right"></div>
      </body>
  </html>
  ```

  

##### 圣杯布局

就是先讲页面分为上中下来划分称为三栏布局，然后在中间再横着切分为三栏布局
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
            html,
            body {
                height: 100%;
            }
            .top,
            .bottom {
                width: 100%;
                height: 50px;
                background-color: #ccc;
            }
            .middle {
                height: calc(100% - 100px);
                background-color: yellow;
            }
            .left,
            .right {
                width: 100px;
                height: 100px;
                background-color: red;
                float: left;
            }
            .center {
                width: calc(100% - 200px);
                height: 100%;
                background: blue;
                float: left;
            }
        </style>
    </head>
    <body>
        <div class="top"></div>
        <div class="middle">
            <div class="left"></div>
            <div class="center"></div>
            <div class="right"></div>
        </div>
        <div class="bottom"></div>
    </body>
</html>

```

##### 弹性盒布局

弹性盒是一种新的布局方式，特别适合移动端布局
给父盒子加`display:flex;`
影响：

- 子元素会默认横向排列，像开了float:left
  - flex-direction 可以给父元素设置`flex-direction`属性改变主轴方向，从而更改子元素排列方式
    `flex-direction`的属性值：
    	row 默认值，类似float:left
    	column 更改为竖向排列，类似没有浮动的盒子堆叠
    	row-reverse 类似float-right
    	column-reverse
  - justify-content 调整主轴对齐方式
    可选属性：
        flex-start: 默认值
        flex-end
        center
        space-between 两端对齐
        space-around 距离环绕
  - align-items 调整侧轴对齐方式 
    可选属性：
        flex-start
        flex-end
        center
- flex-wrap 子元素默认挤在一排，且会让子元素变窄
  可以设置`flex-wrap: wrap;`从而让子元素正常行满换行
  - align-conten 该属性可以设置换行后的元素的行间距排列方式
    属性值有：
        flex-start
        flex-end
        center
        space-around
        space-between
- 若子元素是行内元素，则自动变成了块级元素
- 只有一个子元素的时候，给这个子元素加`margin:auto;`这个元素就会到正中心
- 在父盒子开始弹性布局的子盒子也可以称为项目
- align-self 可以给每一个项目设置对齐方式 
  属性值：
      flex-satrt 默认值
      flex-end 默认值的另一边
      center 中间
      baseline
      stretch 拉伸，若侧轴方向的高或宽没给值，则默认使用这个属性，会把侧轴方向全部占领
- order属性 可以变换项目的排列顺序
  该属性的默认值为0，可以取负值，取值越大越往后面排列
- flex控制剩余的宽高
  属性值为数字，若只给一个设置`flex:1;`，则这个项目拉伸占掉剩下的空间
  若有多个项目设flex属性值，则会根据flex的数字大小进行分配他们几个的空间
- flex-shrink 该属性可以加给项目，控制项目是否接收挤压
  默认值为1 为接收挤压
  修改为0 则不再被挤压变形

##### 多列布局

可以实现用css实现瀑布流效果

- column-count
  该属性规定元素应该被分隔的列数 数字
  适用于：除table外的非替换块级元素，table cells，inline-block元素
- column-gap
  该属性规定列之间的间隔大小 px
- column-rule
  该属性设置或检索对象的列与列之间的边框。复合属性。类似于border
  - column-rule-color规定列之间规则的颜色。
  - column-rule-style规定列之间规则的样式。
  - column-rule-width规定列之间规则的宽度。
- column-fill
  该属性设置或检索所有列的高度是否统一
  auto：列高度自适应内容 这个是尽可能把前面的一列占满，才进下一列
  balance：所有列的高度以其中最高的一列统一 默认值
- column-span
  该属性设置或检索对象元素是否横跨所有列
  none：不跨列
  all：横跨所有列
- column-width
  该属性设置或检索每列的宽度
  这个属性会影响column-count属性的工作，colum-width这个属性使用较少
- break-inside 给里面的元素设置
  avoid 避免该元素在一行显示一半，另一行显示一半

##### 响应式布局

该布局一般只应用到企业的首页上，淘宝啥的不用，因为代码多，而且会浪费一些性能
媒体查询案例

- PC客户端或大屏幕设备：1028px至更大
  `@media only screen and (min-width:1029px){设置的样式}`
- 竖屏
  `@media screen and (orientation:portrait) and (max-width:720px){设置的样式}`
- 横屏
  `@media screen and (orientation:landscape){对应样式}`
- 这个横竖屏检测的原理是计算屏幕的宽高比，所以PC端让屏幕变窄就是竖屏了233

断点：

- 320px 主断点
- 480px 次断点 iphone Android手机横屏
- 样式微调
- 640px 次断点
- 720px 主断点
- 768px 次断点 iPad即某些Android平板电脑横屏
- 1024px 主断点

##### 等比例布局

###### 三种字体单位区别

px: 像素点
em: 相对单位，相对于父元素的字体大小
rem: 相对单位，相对于根元素（html）字体大小
案例：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
            html {
                font-size: 100px;
            }
            body {
                /* 专门给body设置字体大小，来给字体继承，防止出现大的离谱的字体 */
                font-size: 16px;
            }
            .box {
                width: 7.5rem;
                height: 100px;
                background-color: yellow;
            }
        </style>
        <script>
            //fontsize 计算
            document.documentElement.style.fontSize =
                (document.documentElement.clientWidth / 750) * 100 + "px";
            //fontsize = 当前设备的css布局宽度/物理分辨率（设计稿的宽度）*基准font-size
        </script>
    </head>
    <body>
        <div class="box">这是用来测试的文字</div>
    </body>
</html>

```

###### vw,hw辅助实现

100vw 窗口的宽度
100hw 窗口的高度
可以给html设置一个换算后的vw，然后省去用js代码转换
**100vw不同于100%**
在有滚动条的时候，100vw 包含滚动条 是窗口的大小 100%刨除滚动条 剩余的空间占满

##### 网格布局

- 触发网格布局
  给父元素添加display:grid;
  display关于网格的取值分为两个，grid(块网格)和inline-grid(行内网格，行内块)
  grid===容器从上向下排列
  inline-grid===容器从左向右排列
  开启grid布局后，里面的行内元素自动变成块级元素

- 行列划分
  规定行属性：grid-template-row
  固定列属性：grid-template-column
  后面的取值数量代表搞多少行或列

  - 绝对大小
    根本列数或者行数确定值的个数
    例：`grid-temlate-columns: 200px 200px 200px;`
  - 百分比
    根据列数或者行数确定值的个数
    例：`grid-template-column: 33.33% 33.33% 33.33%;`
  - 功能函数repeat()
    repeat(参数1.参数2)
    参数1：重复的次数
    参数2：重复的数值或者重复的样式
    例：`grid-template-columns: repeat(3, 33.33%);`
  - auto-fill关键字（自动填充）配合功能函数使用
    当项目宽高固定，容器不固定的情况下，自动填充网格列数
    例：`grid-template-columns: repeat(auto-fill, 33.33%);`
  - fr关键字（列宽片段）
    为了方便表示比例关系，网格布局提供了fr关键字（fraction的缩写，意为“片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。
    例：`grid-template-columns: 1fr 3fr 1fr;`
  - minmax
    例：`grid-template-rows: minmax(100px,200px) 200px 100px;`
  - auto
    例：`grid-template-rows: 100px auto 200px;`

  若分配的时候超过了100%，则会溢出，不会错误

- 列间距
  行间距：`grid-row-gap: 20px;`
  列间距：`grid-column-gap: 20px;`
  复合式写法：`grid-gap: 30px 30px;`
  新版本已经省略`grid-`前缀 rew-gap \ column-gap \ gap

- 指定区域

  - 使用`grid-template-area:'表示区域的字符串'`
    区域划分必须是矩形或正方形，不能奇奇怪怪的形状，可以用.来代表无所谓的
  - 给子元素`grid-area: a;`注意不要加单引号

- 项目排列顺序
  `grid-auto-flow: column | row;`
  row dense 和 column dense
  这两个值主要用于，某些项目指定位置以后，剩下的怎么自动放置、

- 单元格内容对齐
  justify-items: atart | end | center | stretch;
  aliign-items: astart | end | center | stretch;
  复合写法： `place-items: <justify-items> <align-items>;`

  - start 对齐单元格的起始边缘
  - end 对齐单元格的结束边缘
  - center 单元格内部居中
  - stretch 拉伸，占满单元格的整个宽度（默认值）

- 单元格项目对齐
  justify-content: start | end | center | stretch | space-around | space=between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;
  复合写法： `<justify-content> <align-content>`

  - start 对齐容器的起始边框
  - end 对齐容器的结束边框
  - center 容器内部居中
  - stretch 项目大小没有指定时，拉伸占据整个网络容器。
  - space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。
  - space-between 项目于项目的间隔相等，项目与容器边框之间没有间隔。
  - pace-evenly 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。

- 网格线合并
  grid-column-start属性：左边框所在的垂直网格线
  gird-column-end属性：右边框所在的垂直网格线
  grid-row-start属性：上边框所在的水平网络线
  grid-row-end属性：下边框所在的水平网格线
  网格线编号从1开始

  ```css
  .box div:nth-child(2){
      grid-column-start: 2;
      grid-column-end: 4;
      grid-row-start: 1;
      grid-woe-end: 3;
      /*上面的4行等同于下面两行简写写法*/
      grid-column: 2/4;
      grid-row: 1/3;
  }
  ```

### 背景案例

- 全彩渐变
  ```css
  background: linear-gradient(
                          45deg,
                          hsla(340, 100%, 55%, 1) 0%,
                          hsla(340, 100%, 55%, 0) 70%
                      ),
                      linear-gradient(
                          135deg,
                          hsla(225, 95%, 50%, 1) 10%,
                          hsla(225, 95%, 50%, 0) 80%
                      ),
                      linear-gradient(
                          225deg,
                          hsla(140, 90%, 50%, 1) 10%,
                          hsla(140, 90%, 50%, 0) 80%
                      ),
                      linear-gradient(
                          315deg,
                          hsla(35, 95%, 55%, 1) 100%,
                          hsla(35, 95%, 55%, 0) 70%
                      );
  ```

- 青蓝色WI-FI波纹
  ```css
   background-image: 
          radial-gradient(circle at 100% 150%,#3bc1ac 24%,#42d2bb 25%,#42d2bb 28%, #3bc1ac 36%,#42d2bb 36%,#42d2bb 40%,transparent 40%,transparent),
          radial-gradient(circle at 0 150%,#3bc1ac 24%,#42d2bb 25%,#42d2bb 28%, #3bc1ac 36%,#42d2bb 36%,#42d2bb 40%,transparent 40%,transparent),
          radial-gradient(circle at 50% 100%,#42d2bb 10%,#3bc1ac 11%,#3bc1ac 23%, #42d2bb 24%,#42d2bb 30%,#3bc1ac 31%,#3bc1ac 43%,#42d2bb 44%,#42d2bb 50%,#3bc1ac 51%, #3bc1ac 63%,#42d2bb 64%,#42d2bb 71%,transparent 71%,transparent),
          radial-gradient(circle at 100% 50%,#42d2bb 5%,#3bc1ac 6%,#3bc1ac 15%,#42d2bb 16%,#42d2bb 20%,#3bc1ac 21%,#3bc1ac 30%,#42d2bb 31%,#42d2bb 35%,#3bc1ac 36%,#3bc1ac 45%,#42d2bb 46%,#42d2bb 46%,#42d2bb 49%,transparent 50%,transparent),
          radial-gradient(circle at 0 50%,#42d2bb 5%,#3bc1ac 6%,#3bc1ac 15%,#42d2bb 16%,#42d2bb 20%,#3bc1ac 21%,#3bc1ac 30%,#42d2bb 31%,#42d2bb 35%, #3bc1ac 36%,#3bc1ac 45%,#42d2bb 46%, #42d2bb 49%,transparent 50%,transparent) ;
  
  ```

- 紫色渐变
  ```css
  background: linear-gradient(135deg, #7c1599 0%,#921099 48%,#7e4aeb 100%);
  ```

- 蓝色渐变
  ```css
  background: linear-gradient(45deg, #42a5f5 0%, #478ed1 50%,#0d47a1 100%);
  ```

  

### 其他

鼠标指针样式:(cursor:pointer)
关闭input标签的闪烁框:`outline:none;`
calc()函数

> 用于动态计算长度值
> 运算符有`+ - * /`
> 运算符前后都需要保留一个空格，例如：`width: calc(100% - 10px);`
> 任何长度值都可以使用calc()函数进行计算
> calc()函数使用标准的数学运算优先级规则

修饰浏览器自带的滚动条
```css
::-webkit-scrollbar{/*通过这个伪类选择器就能进行定制化修饰*/
    display: none;/*这样直接隐藏不显示*/
}
```

有些属性前面有`-webkit-`，如`-webkit-radial-gradient`，这个前缀代表chrome的内核，firefox的内核为`-moz-`
contenteditable 枚举属性，控制元素是否可以被直接编辑



  

## js

严格模式：
```js
'use strict';
```



#### 书写位置

##### 行内式

直接把代码书写在标签身上

- a标签 写在href属性上

  `<a href="javascript: JS代码;">点我一下</a>`

- 非a标签 书写在行为属性上
  `<div onclick="alert('hello world')">点我一下</div>`

##### 内嵌式

把代码书写在一个script标签对内
内嵌式JS代码，不需要依赖任何行为，打开页面就会执行

##### 外链式

把代码书写在一个.js文件内
外链式JS代码，不需要依赖任何行为，打开页面就会执行
使用script标签的src属性引入指定JS文件

##### 调试方式

- console.log(a)
  在控制台打印变量
- document.write(a)
  在页面上输出变量
- window.alert(a)
  弹出会话窗口显示变量
- debugger;
  浏览就看到这句代码自动进入调试模式，这句话相当于断点

当js程序出错后，当前script出错后面的代码不执行，其他script的代码正常执行

### 变量

- var
  var会进行预解析
  var可以声明两个重名的变量
  var没有块级作用域
- let
  拥有块级作用域
- const
  必须定义时赋值，赋值后不可改变
  const声明的常量，允许在不重新赋值的情况下修改它的值，就是说对于引用数据类型的属性值可以修改

**什么时候用const，什么时候用let**:
for(let i = 0;i<3;i++)
当犹豫不决选const还是let的时候，先使用const，等报错再改为let
**let,const与var的区别**：

- 重复声明
  已经存在的变量或常量，又声明一遍
  var允许重复声明，let,const不允许

- 变量提升
  var 会提升变量是声明到当前作用域的顶部

  ```js
  console.log(a);//输出undefined
  var a = 1;
  //上面两句相当于下面三句
  var a;
  console.log(a);
  a = 1;
  ```

  let,const不存在变量提升
  ```js
  console.log(a);//这里报错
  let a = 1;
  ```

  这个特性就是让我们写代码的时候要先声明后使用

- 暂时性死区
  只要作用域内存在let，const，它们所声明的变量或常量就自动“绑定”这个区域，不再受到外部作用域的影响

  ```js
  let a = 2;
  function func(){
      console.log(a);//这里报错
      let a = 1;
  }
  func();
  ```

- window对象的属性和方法
  全局作用域中，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法
  let，const不会

- 块级作用域
  let,const有块级作用域
  作用域：全局作用域，函数作用域，块级作用域
  块级作用域：
  {}
  for(){}
  while(){}
  if(){}
  switch(){}
  **块级作用域的经典问题**

  ```js
  var btna = documnet.querySelectorAll('.btn');
  for(var i = 0;i<btns.length;i++){
      btns[i].addEventListener(
      'click',
      function(){
          console.log(i);
      },
      false
      );
  }
  // 上面的写法最终，使3个按钮点击的时候都返回3
  // 因为函数不执行，只声明不会创建自己的函数空间，只有到执行的时候才创建自己的函数空间，因此当监听到点击的时候，才创建函数空间，发现找不到i，就去父级全局命名空间中找，而此时全局命名空间中的i已经变成了3
  //在没有let的时候，使用下面的闭包方法解决
  for(var i = 0; i<btns.length;i++){
      (function(index){
          btns[index].addEventListener(
          'click',
          function(){
              console.log(index);
          },
          false
          );
      })(i);
  }
  //上面这种方式是写立即执行函数，立即执行函数一执行，就立马创建自己函数空间，并存下传入的实参，从而正确记录了i的值
  //下面是let的解决方案
  for(let i =0;i<btns.length;i++){
      btns[i].addEventListener(
      'click',
      function(){
          console.log(i);
      },
      false
      );
  }
  // let创建块级作用域，因为i变化了3次，因为创建了3个块级作用域，里面i分别等于0,1,2
  ```

  

### 数据类型

#### 基本数据类型

- Number
  数值类型
  包含一般整数`100`，负数`-100`，小数`-100.23`，科学进制数`2e5`，十六进制`0x100`，八进制`0o100`，二进制`0b100`，`NaN` 非数字
- String
  字符串类型
  双引号或单引号引起来的字符串
  - 常用函数
    - charAt() 按照索引获取字符
    - toLowerCase() 转小写
    - toUpperCase() 转大写
    - replace() 替换字符串
    - trim() 去除首位空格
    - split() 切割字符串
    - substr() 截取字符串
    - substring() 截取字符串
    - slice() 截取字符串
- Boolean
  布尔类型
  `true` 真    `false` 假
- 空类型
  - undefined
    表示没有值
  - null
    表示有值，一个空值
    typeof 返回Object

##### typeof

保留关键字，用来返回数据类型，不是函数不加括号

##### 数据类型转换

**转数值**

- Number();
  语法：Number要转换的内容)
  结果：转换好数值类型的结果
  如果无法转换成数字，则返回NAN
- parseInt();
  语法：parseInt(要转换的内容)
  结果：转换好数值类型的结果
  `parseInt('100abc')`返回`100`
- parseFloat();
  语法：parseFloat(要转换的内容)
  结果：转换好数值类型的结果

**转字符串**

- String();
  语法：Sting(要转换的内容)
  结果：转换好字符串类型的结果
- toString();
  语法：要转换的内容.toString()
  结果：转换好字符串类型的结果

**转布尔**

- Boolean();
  要转换的内容.Boolean()
  结果：转换好布尔类型的结果
  false: 0 NaN '' undefined null
  true:其他所有的

##### 模板字符串

使用键盘左上角报起来的字符串
```js
var a = 1
var s = `模板字
符串 ${a}`;
```

模板字符串可以换行书写，且保留换行时的空格换行等
可以直接在字符串内解析变量，书写`${变量名}`
只要最终可以得出一个值的就可以通过${}注入到模板字符串中

#### 引用数据类型

##### 对象
键值对的集合
`var obj =  {key:value, 键:值};`

- 增
  `obj.name='小灰狼;'`
  `obj['age']=16;`
  
- 删
  `delete obj.name;`
  `delete obj['age'];`
  
- 改
  `obj.name='name2';`
  `obj['age']=61;`
  
- 查
  `console.log(obj.name);`
  `console.log(obj['age']);`

##### 数组
  有序的数据的集合

  - 创建
    `var arr =  [100, true, 'hi', 任何类型数据];`
  - 操作
    - 长度
      访问：`数组.length`
      设置：`数组.length = 数字;`当数字小于数组长度时候会从后面截断
    - 数据
      访问：`数组[索引]`
      设置：`数组[索引]=值`
    - 遍历
  - 常用函数
    - push() 从后面追加
    
    - pop() 从后面删除
    
    - unshift() 从前面添加
    
    - shift() 从前面删除
    
    - reverse() 反转数组
    
    - splice() 截取并添加
      splice的index可以取负值
      示例:
    
      ```js
      const secretCode = "arvin";
      const pressed = [];
      window.addEventListener("keyup", (e) => {
      	console.log(e.key);
      	pressed.push(e.key);
      	pressed.splice(
      		-pressed.length - 1,
      		pressed.length - secretCode.length
      	);
      	console.log(pressed);
      });
      ```
    
      
    
    - sort() 数组排序
    
    - join() 数组链接为字符串
    
    - concat() 拼接数组
    
    - slice() 截取数组
    
    - indexOf() 查找数据在数组中的索引
    
    - forEach() 遍历数组
    
    - map() 映射数组
    
    - filter() 过滤数组
    
    - every() 判断是否全部满足条件
    
    - some() 判断是否有满足条件的项

##### 集合

Set是一系列无序，没有重复值的数据集合
```js
const s = new Ste();
s.add(1).add(2).add(2);
console.log(s);//输出s{1,2}
console.log(s.has(3));//输出false
s.delete(3);
console.log(s);//输出s{1,2}
s.clear();
console.log(s);//输出s{}
s.add(1).add(2);
//遍历集合 forEach
s.forEach(function(value,key,set){
    //Set中value=key，为了统一forEach才留这两个一样的参数
    //set参数就是s本身
}，documet);//这个document这个位置可以传参当作里面遍历的this指向对象
//set的遍历顺序是按照成员添加进集合的顺序遍历
//属性
console.log(s.size);//输出2
```

Set的构造函数`new Set()`中可以放参数：数组，字符串，arguments，NodeList，Set(这样就是复制一个集合)
Set对重复值的判断基本遵守严格相等（===），但是对于NaN的判断与===不同，Set中NaN等于NaN
Set的应用：

- 数组去重
  ```js
  arr = [1,2,1]
  arr_2 = [..new Set(arr)];
  console.log(arr_2);//输出[1,2]
  ```

- 字符串去重
  ```js
  str = 'abbacbd';
  str_2 = [...new Set(str)].join('');
  console.log(str_2);//输出'abcd'
  ```

##### Map

映射，Map和对象都是键值对的集合
对象一般用字符串当作键，但Map可以用所有的数据类型当作键
方法：

- set
  使用set添加的新成员，键如果已经存在，后添加的键值对覆盖已有的
- get
  get获取不存在的成员，返回undefined
- has
- delete
  使用delete删除不存在的成员，什么都不会发生，也不会报错
- clear
- forEach

属性：

- size
  对象没有这个类似的属性

Map的构造函数里面可以传递二维数组，且必须体现出键和值，也可以传Set，Map(复制一个)
Map判断键名是否相同的方式与Set完全类似
Map应用：
Map与forEach不同的是，Map会返回新数组，而forEach是在原数组上操作，因此在需要对数组元素操作后返回新数组的时候使用Map

#### 变量拷贝

- 对于基本数据类型，将其赋值传递给另一个变量的时候，是深拷贝的
- 对于引用数据类型，将其赋值传递给另一个变量的时候，是浅拷贝
  - 

### 运算符

#### 算数运算符
进行数学运算的符号

- `+`：进行加法元素
  当符号两边都是数字或者布尔的时候，会进行数学运算
- `-`：进行减法运算
- `*`：进行乘法运算
- `/`:进行除法运算
- `%`：进行取余运算

#### 赋值运算符
进行赋值操作的符号

- `=`：进行赋值操作
- `+=`：加等于运算符
- `-=`：减等于运算符
- `*=`：乘等于运算符
- `/=`：除等于运算符
- `%=`：取余等于运算符

#### 比较运算符
进行比较运算的符号

- `>`：大于比较
- `<`：小于比较
- `>=`：大于等于
- `<=`：小于等于
- `==`：等于比较
  只比较值，不考虑数据类型
- `===`：全等于比较
  比较值和数据类型
- `!=`：不等于比较
- `!==`：不全等于比较

#### 逻辑运算符
进行逻辑运算的符号

- `&&`：与运算

- `||`：或运算

- `!`：非运算

- 自增自减原算法
  单独对一个变量进行+1或者-1操作的符号
  - `++`
  - `--`


  #### 展开运算符
 `...`
作用：展开数组的[]或者展开对象的{}

  ```js
  var arr = [100, 200, 300];
  console.log(...arr);
  console.log(100, 200, 300);
  //上面两个打印的结果一样
  
  console.log(Math.min(...[3,1,2]));
  //相当于
  console.log(Math.min(3,1,2));
  ```

  可以用于合并数组
  ```js
  var arr1 = [10, 20];
  var arr2 = [30, 40];
  var arr3 = [...arr1, ...arr2];
  ```

  还可以用于给函数传递参数，类似于拆包
  不能`console.log(...obj)`，因为对象的键值对拆掉{}后语法错误
  展开对象一般用于复制对象，要注意书写的位置

  ```js
  var obj = {name: 'Jack', age: 18};
  var obj2 = {gender: '男', ...obj, name: 'Rose'}
  ```

  应用：

  - 复制数组
    `const c = [...a];`
  
  - 合并数组
    `const c = [...a,...b]`
  
  - 字符串转为数组
    ```js
    console.log([...'alex']);
    //也可以用内置函数
    console.log('alex'.split(''));
    ```
  
  - 常见的类数组转化为数组
  
    - arguments
      ```js
      function func(){
          console.log([...arguments]);
      }
      ```
    
    - NodeList
      ```js
      console.log([...documnet.querySelectorAll('p')]);
      ```

展开对象{}:
对象不能直接展开，必须再{}中展开

```js
const apple = {
    color: '红色',
    shape: '球形',
    taste: '甜'
};
console.log({...apple});
```

新对象的展开：把属性罗列出来，用逗号分隔，放到一个{}中，构成新对象
合并对象：

```js
const pen = {
    color: '黑色',
    shape: '圆柱形',
    use: '写字'
};
console.log({...apple,...pen});
```

新对象拥有全部属性，相同属性，后者覆盖前者
空对象的展开：如果展开一个空对象，则没有任何效果
非对象的展开：如果展开的不是对象，则会自动将其转为对象，再将其属性罗列出来

```js
console.log({...1});
console.log({...undefined});
console.log({...null});
console.log({...true});
//上面展开后的输出都是'{}'
```

如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象
```js
console,log([...'alex']);
//输出 {0:"a",1:"l",2:"e",3:"x"}
console.log({...[1,2,3]});
//输出 {1:1,1:2,2:3}
```

不会展开对象中的对象属性
```js
const apple = {
    feature:{
	taste:'甜'
    }
};
const pen = {
    feature: {
        color: '黑色',
        shape: '圆柱形'
    },
    use: '写字'
};
console.log({...apple,..pen});
//上面的输出相当于
console.log({
    feature: {
        color: '黑色',
        shape: '圆柱形'
    },
    use: '写字'
});
```

对象展开的应用

- 复制对象
  ```js
  const a = {x:1,y:2};
  const b = {...a};
  ```

- 第二种给函数赋初值的方法
  ```js
  const logUser = userParam => {
      const defaultParam = {
          username: 'ZhangSan',
          age: 0,
          sex: 'male'
      };
      const param = {...defaultParam, ...userParam};
      console.log(param.username);
  }
  ```

  

### 逻辑控制

#### if

```js
if(){...}
if(){...} else{...}
if(){...} else if(){...}
if(){...} else if(){...} else{...}
```

#### switch

```js
switch(){
    case 选项一:
	...
	break;
    case 选项二:
	...
    break;
    default:
	...
}
```

#### while

```js
定义初始变量 n
while(条件){
    会被重复执行的代码
   	...改变初始值
}
```

#### dowhile

```js
定义初始变量 n
do{
    会被重复执行的代码
    ...改变初始值
}while(条件)
```

#### for

```js
for(定义初始变量; 条件判断; 改变初始值){
    重复执行的代码
    ...
}
```

###### for in

```js
m.forEach((propObj, elem) => {
    for (const p in propObj){
        elem.style[p] = propObj[p];
    }
});
```



### 函数

定义：
```js
function fn(形参){
    装在盒子里面的代码
    ...
    return 返回值
}
```

- 带函数名
  - `function funcName (param){statement}`
  - `const funcName = function (param){statement}`
- 不带函数名（匿名定义）
  `(function(param){statement})`

调用：
`函数名(实参)`
函数就是JS中的一个数据类型而已

#### 作用域

- 范围
  - 全局作用域
    一个页面就是一个全局作用域
  - 私有作用域
    只有函数 生成私有作用域
- 使用
  - 定义
    声明在什么位置的变量式哪一个作用域的变量
  - 访问
    自己有用自己的，自己没有用父级的，依次类推，到全局都没有就报错
  - 赋值
    自己给自己的赋值，自己没有给父级的赋值，依次类推，到全局都没有，定义为全局再赋值

#### 箭头函数

```js
var fn = function(){console.log('hi')}
var fn2 = () => {console.log('hi')}
const add = (x,y) => {
    return x+y;
};
```

箭头函数的结构
const/let 函数名 = 参数 => 函数体
如何将一般函数改写成箭头函数

```js
//声明形式
function add(){}
//声明形式->函数表达式形式
const add = function(){}
//最终
const add = () =>{};
```

箭头函数的特殊之处

- 箭头函数在形参只有一个的时候可以省略括号
  ```js
  keys.forEach(key => {
      console.log(key);
  })
  const add = x =>{
      return x+1;
  };
  ```

  无参数或多个参数不能省略圆括号

- 箭头函数在代码只有一句话时候可以不写{}，并且会自动把这一句话的结果当作函数的返回值
  `const add = (x,y) => x + y;`

- 返回单行对象时的省略写法：
  ```js
  const add = (x,y) => ({
      value:x+y
  });
  ```

  如果箭头函数返回单行对象，可以在{}外面加上(),让浏览器不再认为那是函数体的花括号
  `const add = (x,y) => [x,y]`

- 箭头函数没有arguments

- 箭头函数内没有this，箭头函数内的this就是外部作用域的this

无法使用箭头函数的场景：

- 作为构造函数
  构造函数不可以缺this

- 需要this指向调用对象的时候
  比如监听事件函数

  ```js
  document.onclick = function(){
      console.log(this);
  };
  ```

- 需要使用argunments的时候
  比如不定长参数求和函数

箭头函数的应用：
```js
const timer = {
    time: 0,
    start: function(){
        //this
        btn.addEventListener(
        'click',
        ()=>{
            setInterval(()=>{
                console.log(this);
                this.time++;
                result.innerHTML = this.time;
            },1000);
        },
        false
        );
    }
};
```



#### 函数默认值

和python一样，在函数定义的时候等号给个值
如果默认值是表达式，默认值表达式是惰性求值的
函数参数的默认值，最好从参数列表的右边开始设置（不像python有强制要求）
**函数默认值在开发中的使用**:

```js
const logUser = ({username='zhangsan',age=0,sex='male'}={})=>console.log(username,age,sex);
//{username='zhangsan',age=0,sex='male'}是给username,age,sex对象解构时候的初值
//{username='zhangsan',age=0,sex='male'}={}是给函数第一个参数给默认值'{}'
```



#### this指向

- 全局作用域中的this指向window

- 一般函数（非箭头函数）中的this指向
  只有在函数调用的时候this指向才确定，不调用的时候，不知道指向谁
  this指向和函数在哪儿调用没关系，只和谁调用有关

  ```js
  function add(){
      console.log(this);
  }
  add();//严格模式就指向undefined 非严格模式指向window
  //上面的add就是前面根本没有'.'，完全不知道是谁调用，就默认找undefined
  //某些函数如setInterval(function a(){};)中的a函数，a函数是一般函数，也是找不到调用者，它里面的this就不会去找父级，而是直接认为自己是undefind
  
  const calc = {
      add:add
  };
  calc.add();//this指向调用者calc这个对象
  
  const adder = calc.add;
  adder();//此时调用者是个变量名，因此严格模式下就是underfined，非严格模式下自动指向window
  
  document.onclick = function(){
      console.log(this);
  };
  document.onclick();//调用者毫无疑问是.前面的document
  
  function Person(username){
      this.username = username;
      console.log(this);
  }
  const p = new Person('Alex');//调用构造函数，this不再是指向变量名，而是指向新构建的对象本身，相当于，创建了个temp变量，temo变量调用__init__函数，this指向这个temp,最后再把temp赋值给p变量
  ```

- 箭头函数中的this指向
  箭头函数没有自己的this

  ```js
  const calc = {
      add:()=>{
  	console.log(this);
      }
  };
  calc.add();//add是箭头箭头函数，自己没有this，去父级找，一直找到window没找到，就被全局的this指向window了
  ```

  

#### 解构赋值

类似于拆包
解析某一数据的结构，将我们想要的东西提取出来，赋值给变量或常量

- 数组解构
  `let [a, b] = ['hello', 'world']` a变量得到'hello'，b变量得到'world'
  
  ```js
  //1,模式（结构）匹配
  //2.索引值相同的完成赋值
  //不取的可以直接用逗号跳过
  const [a,[,,b],c] = [1,[2,4,5],3]
  
  const [d,e] = [];//d,e都为undefined
  //默认值的基本用法
  const [e=1,f=2] = [] //e=1,f=2
  //默认值生效的条件
  //只有当一个数组成员严格等于(===)undefined时，对应的默认值才会生效
  const [g=1,h=2] = [3,null] //g=3,h=null
  const [i=1,j=2] = [3,undefined] //i=3,j=2
  //如果默认值是表达式，默认值表达式是惰性求值的
  const func = ()=>{
      console.log('我是惰性执行的');
      return 2;
  };
  const [x=func()] = [1];//此时不执行上面的惰性函数
  
  ```
  
  - 常见的类数组的解构赋值
    ```js
    //arguments
    function func(){
        const [a,b] = arguments;
    }
    func(1,2);//a=1,b=2
    
    //NodeList
    const [p1,p2,p3] = document.querySelectorAll('p');
    ```
  
  - 函数参数的解构赋值
    ```js
    const array = [1,1];
    const add = ([x=0,y=0]) => x+y;
    console.log(add(array));//输出2
    console.log(add([]));//输出0
    ```
  
  - 交换变量的值
    ```js
    let x=1;
    let y=2;
    [x,y] = [y.x];
    //注意这里理解，不是直接x=y,y=x,而是先变成[x,y]=[2,1]
    console.log(x,y);//输出2 1
    ```
  
    
  
- 对象解构
  var{name} = obj 此时用name变量去对象中找name属性，这样用名字必须统一
  var{age:a}=obj 此时定义变量a去对象中找age属性
  花括号中可以按照上面的规则一次写多个
  
  ```js
  //1.模式（结构）匹配
  //属性名相同的完成赋值
  const {age,username} = {username:'Alex',age:18};//age变量值为18，username变量值为'Alex'
  const {age:age,'username':username}= {username:'Alex',age:18};//这是上=一行的完整写法，就是先匹配键（字符串类型），然后再对应的给变量赋值
  //取别名
  const{age:myage,username:uname}={username:'Alex',age:18};
  console.log(myage,uname);//18 'Alex'
  ```
  
  ```js
  //默认值的生效条件
  //对象的属性值严格等于undefined时，对应的默认值才会生效
  const {username='ZhangSan', age = 0} = {username='alex'}
  //如果默认值时表达式。默认值表达式是惰性求值
  //如果将一个已经声明的变量用于对象的解构赋值，整个赋值需要再圆括号中进行
  let x = 2;
  ({x}={x:1});
  consle.log(x);//输出2
  //可以渠道继承的属性
  const {toDtring} = {};
  console.log(toString);//输出从Object继承的toString
  ```
  
- 其他数据类型的解构

  - 字符串的解构赋值
    字符串既可以按数组形式来解构赋值，也可以按对象形式来解构赋值

    ```js
    //数组形式的解构赋值
    const [a,b,,,c] = 'hello';
    console.log(a,b,c);//h e o
    //对象形式的解构赋值
    const {0:a,1:b,length}='hello';
    console.log(a,b,length);//h e 5
    ```

  - 数值和布尔值的解构赋值
    先自动将等号右边的值转为对象

    ```js
    const {a,toString}=123;
    console.log(a,toString);//undefined f(...)
    ```

  - undefined和null的解构赋值
    由于undefined和null无法转为包装对象，所以对它们进行解构赋值，都会报错

#### 剩余参数

```js
const add = (x,y,...args)=>{//args这个变量名随便起，前面有有三个点
    console.log(x,y,args)//调用的时候不用写前面的三个点
};
```

剩余参数永远是个数组，即使没有值，也是空数组

- 箭头函数的剩余参数
  箭头函数的参数部分即使只有一个剩余参数，也不能省略圆括号`const add=(...args)=>{}`

- 使用剩余参数替代arguments获取实际参数
  ```js
  //普通函数可以用aruments
  const add = function(){
      console.log(arguments);
  };
  const add = (...args)=>{
      console.log(args);
  }
  ```

- 剩余参数的位置
  剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错

应用：

- 完成add函数
  ```js
  const add = (...args) =>{
      let sum = 0;
      for (let i =0;i<args.length;i++){
          sum+=args[i];
      }
      return sum;
  }
  ```

- 与解构赋值结合使用
  必须是最后一个

  ```js
  const [num,..args] = [1,2,3,4];
  cont dunc = ({x,y,...z}) => {};
  func({a:3,x:1,y:2,b:4});
  ```

###### 剩余参数和展开运算符

根本区别：
剩余参数：3,1,2 -> [3,1,2]
展开运算符：[3,1,2] -> 3,1,2
示例：

```js
const add = (...args) => {//这行的...args是剩余参数
    console.log(...args);//这行的..args是展开运算符
}
```

#### 复合语法

##### 闭包

- 定义
  - 函数的返回值可以为函数
  - 所有的参数和变量都保存在返回函数中
  - 当调用返回函数时才会执行所有的运算逻辑
- 用途
  - 匿名自执行函数
  - 封装
  - 结果缓存

##### 高阶函数

- 定义
  - 接收另一个函数作为参数的函数被称为高阶函数
  - 完全类似于python的装饰器
- 用途
  - 回调
    - Callback
  - 数组操作
    - filter,sort,map,forEach



### 内置库

##### Math

- random() 0~1之间的随机小数
- round() 四舍五入取整
- ceil() 向上取整
- floor() 向下取整
- pow() 取幂
- sqrt() 二次方根
- abs() 取绝对值
- max() 取最大值
- min() 取最小值
- PI 近似pai的值

封装的函数

- 获取随机整数
  ```js
  function ransomNum(min, max){
      //秋0~两数差的随机整数
      var res = Math.floor(Math.random()*(max-min+1))
      //使用随机整数+min
      return res+min
  }
  ```

##### Date

`var time = new Date();`
获取时间的函数

- getFullYear()
- getMonth()
- getDate()
- getHours()
- getMinutes()
- getSeconds()
- getDay()
- getTime()

设置时间的函数

- setFullYear(数字)
- setMonth(数字)
- setDate(数字)
- setHours(数字)
- setMinutes(数字)
- setSeconds(数字)
- setTime(数字)

##### BOM

- 获取浏览器窗口尺寸
  - 宽度：`window.innerWidth`
  - 高度：`window.innerHeight`
- 浏览器弹出层
  - 提示框：`window.alert()`
  - 询问框：`window.confirm()`
  - 输入框：`window.prompt()`
- 开启和关闭标签页
  - 开启：`window.open()`
  - 关闭：`window.close()`
- 浏览器的历史操作
  - 回退：`window.history.back()`
  - 前进：`window.history.forward()`
- 浏览器的常见事件
  资源加载完毕：`window.onload = function(){}`
  页面尺寸改变：`window.onresize = function(){}`
  滚动条位置改变：`window.onscroll = function(){}`
- 浏览器卷去的尺寸
  - 高度
    `document.documentElement.scrollTop`
    `document.body.scrollTop`
  - 宽度
    `document.documentElement.scrollLeft`
    `document.body.scro9llLeft`
- 浏览器滚动到
  `window.scrollTo(left, top)`
  `window.scrollTo({left: xx, top: yy, behavior: 'smooth'});`
- 修改网页地址
  `window.location.href`
  可以通过赋值的方法进行网页跳转

##### 定时器

- 开始定时器
  间隔定时器：`setInterval(函数，时间)`
  延时定时器：`setTimeout(函数，时间)`
- 定时器返回值
  不区分定时器种类
  表示页面上的第几个定时器
  作用：关闭定时器
- 关闭定时器
  clearInterval(定时器返回值)
  clearTimeout(定时器返回值)
  上面两个函数功能一样，两种定时器都能关

##### DOM

- 获取元素
  - 根据id名称获取
    `document.getElementById('id名称')`
  - 根本元素类名获取
    `documnet,getElementsByClassName('元素类名')`
  - 根据元素标签名获取
    `documnet.getElemntsByTagName('标签名')`
  - 根据选择器获取一个元素
    `document.querySelector('选择器')`
  - 根据选择器获取一组
    `document.querSelectorAll('选择器')`
- 操作元素内容
  - 操作元素文本内容
    获取：元素.innerText
    设置：元素.innerText = '新内容'
  - 操作元素超文本内容
    获取：元素.innerHTML
    设置：元素.innerHTML = '新内容'
- 操作元素属性
  - 原生属性
    获取：元素.属性名
    设置：元素.属性名 = '属性值'
  - 自定义属性
    获取：元素.getAttribute('属性名')
    设置：元素.setAttribute('属性名', '属性值')
    删除：元素.removeAttribute('属性名')
- 操作元素类名
  获取：元素.className
  设置：元素.className = '新类名'
- 操作样式
  - 操作元素行内样式
    获取：元素.style.样式名
    设置：元素.style.样式名 = '样式值'
  - 获取元素非行内样式
    Window.getComputedStyle(元素).样式名
- 节点操作
  - 创建节点 `document.creatElement('标签名称')`
  - 插入节点
    父节点.appendChild(子节点)
    父节点.insertBefore(要插入的子节点，哪一个子节点的前面)
  - 删除节点
    父节点.removeChild(子节点)
    节点.remove()
  - 替换节点
    父节点,replaceChild(换上节点，换下节点)
  - 克隆节点
    节点.cloneNode(是否克隆后代节点)
- 获取元素尺寸
  - 元素.offsetHeight
    元素.offsetWidth
    元素内容+padding+border
  - 元素.clientHeight
    元素.clientWidth
    元素内容+padding

##### JSON

JSON.stringify 序列化
JSON.parse 反序列化

### 事件

##### 事件循环

- 定义：主线程不断地重复获取执行消息，再获取执行不断循环的机制被称为事件循环
- 为什么需要事件循环
  - JS是单线程的
  - 在处理异步操作的时候需要事件循环机制
- 相关概念
  - 堆（Heap）:大块非结构化内存区域，存储对象，数据
  - 栈（Stack）:调用栈，存储该次循环待主进程执行的任务
  - 队列（Queue）:事件队列，先进先出被推入调用栈中
- 宏任务（Macro Task）和微任务（Micro Task）
- Node.js 事件循环

##### 事件监听

###### 键盘事件监听

键盘事件监听一般就绑定在window对象上

- e.key 可以获得输入的键盘字符

##### 事件的传播

##### 阻止事件传播
语法:
事件对象.stopPropagation()

##### 事件委托

```js
//1.获取到ul元素
var ul = document.querySelector('ul')
//2.给ul绑定点击事件
ul.onclick = function(e){
    //3.通过事件目标来判断你点击的是li
    if(e.target.tagName === 'LI'){
        console.log('你点击的是li');
    }
}
```

##### 事件监听参数

```js
divs.forEach((div) =>
	div.addEventListener("click", log, {
		capture: true,//这个参数为ture则在捕获阶段就执行
		once: true,//这个参数为ture就使回调函数只执行一次
	})
);
```



### 面向对象

##### 构造函数

构造函数和普通函数没有大区别，构造函数是调用的时候和new关键字连用，因为只有和new关键字连用的时候，这个函数才会有自动创建和返回对象的能力。然后构造函数的函数名规范大写
构造函数内部不要乱写return，当return一个基本数据类型时，这个return语句不生效，当return一个复杂数据类型时，取值按return的值进行赋值，不听new关键字的。
构造函数的不合理：当在对象上加方法的时候，只要创建一次对象就会有一个新函数占用空间，创建100次对象，会有100个一模一样的函数出现

##### 原型

prototype
定义：每一个函数天生自带一个属性，叫做prototype，说一个对象
构造函数也是函数，也会有这个自带的空间prototype
既然prototype是一个对象，我们就可以使用对象操作的语法，向里面添加一些内容

```js
function Person(){}
Person.prototype.sayHi = function(){console.log('我是Person原型上的方法')}
```

##### 类

- 声明形式`class Person{}`

- 表达式形式
  ```js
  const Person = class {};
  new (class {})();//匿名的立即执行表达式
  ```

  

```js
class Person{
    constructor(name, age){
        // 这个函数相当于__init__，但必须重写
        this.name = name
        this.age = age
    }
    //普通方法直接在这写就行
    sayHi(){console.log('你好')}
    //静态属性
	static a = 100;
    //静态方法
    static go(){console.log('go')}
}
//上面在ES6以前的写法如下
function Person(name, age){
    this.name = name
    this.age = age
}
//需要单独再给函数
Person.propotype.sayHi = function(){console.log('你好')}
//静态的省略，因为ES6前没有静态static这个保留字
```

###### 私有化

- 在变量名前面加`_`

- 将私有属性和方法移除类，定义在模块中
  ```js
  (function (){
      let name = '';
      class Person{
          constructor(username){
              name = username;
          }
          speak(){
              console.log('speak');
          }
          getName(){
              return name;
          }
      }
  })();
  ```

###### 继承

```js
class Programmer extends Person {//通过extends可以继承当前父类所有的属性和方法的状态
    constructor(name,sex,festure){
        //不能在super前面使用this赋值,会直接报错
        super(name,sex);
        this.feature = feature;
    }
    speak(){
        console.log('Programmer speak');
    }
    //若想修改父类的属性或方法可以直接同名覆盖
}
```

###### super

- 作为函数调用
  代表父类的构造方法，只能用在子类的构造方法中，用在其他地方就会报错
  super虽然代表了父类的构造方法，但是内部的this指向子类的实例
- 作为对象使用
  在构造方法中使用或一般方法中使用，super代表父类的原型对象Person.prototype
  所有定义在父类实例上的方法或属性，是无法通过super调用的
  通过super调用父类的方法时，方法内部的this指向当前的子类实例
- 在静态方法中使用
  指向父类，而不是父类的原型对象
  通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例

使用super的时候，必须显式指定是作为函数还是作为对象使用，否则会报错

##### 原型链

- 概念
  - prototype
  - `__proto__`
  - constructor
- 应用场景
  - 继承，代码复用



### 异步编程

ES5  回调地狱
ES6  Promise
ES8  async/await

- async/await
  - ES8(ES2017)中出现的异步解决方案
  - 是基于Promise的语法糖，需要了解Promise相关知识
  - async返回Promise对象
  - async函数遇到await是会终止运行，直到相应的Promise状态变为resolved
  - 优点：解决了Promise代码可读性问题，代码可读性高
  - 缺点：多个并行异步操作需要用Promise.all来执行                    

### 浏览器储存

- Cookies
  - 主要用于与服务端通信
  - 储存量小
- Local Storage
  - 储存量相较于Cookies更大
  
  - 只能存储字符串
    因为对象转字符串会变成{{Object Object}}
  
    ```js
    localStorage.setItem('tasks', JSON.stringify(tasks));
    ```
  
- Session Storage
  - 只存在于当前Session，关闭浏览器就丢失了
  - 其他与Local Storage 一样
- IndexedDB
  - 相当于浏览器上的SQL数据库
  - 更大的存储空间
  - API较难掌握

### 跨域

定义：客户端与不同源的服务端通信
解决办法

- CROS
  - 跨域资源共享，解决跨域请求的方案的成熟方案
- JSONP
  - 基于`<script>`标签具有可跨域特性
  - 只能用于GET请求
- iframe
  - 通过`<iframe>`标签在一个页面展示不同源的页面
  - 通过PostMessage进行页面之间的通信
- 反向代理
  - 通过反向代理让客户端与服务端保持同源

### Es6其他语法

##### 字面量省略

- 对象字面量
  ```js
  //实例化构造函数生产对象
  const person = new Object();
  person.age = 18;
  person.speak = function(){}
  //对象字面量方法生成对象
  const person={
      age:18,
      speak:function(){}
  }
  ```

  - 字面量属性的简洁表示法
    键名和变量或常量名一样的时候，可以只写一个

    ```js
    const age = 18;
    const person={
        //age:age,
        age,
    }
    ```

  - 字面量方法的简洁表示法
    方法可以省略冒号和function关键字

    ```js
    const person = {
        //speak function(){}
        speak(){}
    };
    ```

##### 方括号

- 方括号语法的用法

  ```js
  person.prop = 18;
  person[prop]=18;
  
  const func = ()=>'age2'
  const person={
      [prop]:18,
      [funx()]:18,
      ['s'+'ex']:'male'
  };
  ```

  方括号中可以放通过计算得到的值

##### Iterator 遍历器

类似于python的生成器
是一个统一的遍历方式

```js
const arr = [1,2,3];
const it = arr[Symbol.iterator]();
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
```

上面是最基础的使用方法，但用起来过于麻烦，因此引入了for of
```js
for(const item of arr){
    console.log(item);
}
```

entries()可以得到索引＋值组成的数组的可遍历对象
```js
for(const entries of arr.entries()){
    console.log(entries)
}
```

还可以同时获得索引和值

```js
for(const [index,vaule] pf arr.entries()){
    console.log(index,value);
}
```

###### 可遍历

只要有`Symbol.iterator`方法，并且这个方法可以生成可遍历对象，就是可遍历的
只要可遍历，就可以使用for...of循环来统一遍历

- 原生可遍历

  - 数组
  - 字符串
  - Set
  - Map
  - arguments
  - NodeList

- 非原生可遍历

  - 一般情况
    ```js
    const person = {sex: 'male', age:18};
    person[Symbol.iterator] = () => {
        let index = 0;
        return {
            next(){
                index++;
                if(index === 1){
                    return {
                        value: person.age,
                        done:false
                    };
                }else if(index === 2){
                    return {
                        value: person.sex,
                        done: false
                    };
                }else{
                    return {
                        done: true
                    };
                }
            }
        };
    };
    ```

  - 有length和索引属性的对象
    ```js
    const obj = {
        0:'alex',
        1:'male',
        length:2
    };
    obj[Symbol.iterator] = () =>{
        let index = 0;
        retrun {
            next(){
                let value,done;
                if(index < obj.length){
                    value = obj[index];
                    done = false;
                }else{
                    value = undefined;
                    done = true;
                }
                index++;
                return {
                    value,
                    done
                };
            }
        }
    }
    ```

  - 对于有索引和length属性的对象还可以直接借用Array的遍历器
    ```js
    obj[Symbol.iterator] = Array.prototype[Symbol.iterator];
    ```


###### 新的遍历对象

数组的keys()，values()，entries()等方法是实例方法，返回的都是Iterator
对象的Object.keys()。Object.values()，Object.entries()等方法是构造函数方法，返回的是数组
Object.keys/values()/entires()并不能保证顺序一定是你看到的样子，这一点和for in是一样的

##### Module模块

模块解决的主要问题：

- 模块化编程的问题
- 消除全局变量污染
- 管理加载顺序

Module的加载：
使用script标签加载模块时需要添加type="module"

一个模块如果没有导出，然后被另一个模块导入，则被导入的模块会执行一遍里面的代码，且只会执行一次，多次导入无效。

export default 和对应的 import:
export default 用于导出一个默认值，一个模块只能有一个。
导出：`export default age/20/{}...`只能跟一个值
导入：`import age form './module.js'`age可以换其他的变量名，这个变量名可以随便起

export和对应的import:
导出导入时候都可以临时起名字
导出：`exprot 声明或语句`或`export {fn as func,className,age}`
导入： `import 变量名 from './module.js'`接收的变量名必须和导出时候的变量名对应上 或 `import {func, age, className as Person} form './module.js'` 导入时候变量名字对应上就可，顺序无所谓
可以同时全部导入到一个对象中：`import * as obj from './module.js'`这个obj中包含export default的变量，被命名为default

同时导入exporty default 和export导出的内容
`import userAge,{age,fn,className} form './module.js';`

若export default 和 export 同时使用，则要把export default 放在前面 

模块顶层的this指向undefined

import 和 export 只能在模块的顶层，不能在代码块中执行。

import命令具有提升效果，会提升到整个模块的头部，率先执行。因此import命令无法根据条件，比如看是手机端引入手机端的文件，电脑端引入电脑端的文件。若想实现根据条件引入可以使用`import()`，这个函数会返回一个Promise对象。

导入导出的复合写法：`export {age} form './module.js';`
等价于：`import {age} form './module.js';export {age} from './module.js';`
但是这个复合写法，会导致变量无法在当前模块使用，age是访问不到的，只是传递变量给下一个模块

#### Promise

Promise解决的不是回调函数，而是回调地狱
Promise有3种状态，一开始是pending(未完成)，执行resolve，变成fulfilled(resolved)，已成功。执行reject则是变成rejected，已失败。
Promise的状态一旦变化，就不会再改变了

##### then

```js
p.then(
	() => {
        console.log('success','这是成功才执行的回调函数')
    },
    () => {
        console.log('error', '这是失败才执行的回调函数')
    }
)
```

默认返回的状态是成功

##### catch

catch专门用来处理rejected状态
catch本质上是then的特例`then(null,err => {})`
catch()可以捕获它前面的错误，错误也是会一路向后面穿透，直到被捕获，若最后都没被捕获，则会抛出到控制台
一般总是建议，Promise对象后面要跟catch方法，这样可以处理Promise内部发生的错误

##### finally

finally用来写最后一定要执行的代码，比如释放数据库等资源。
可以将finally视为将不管成功还是失败的代码状态都直接传递给下一个的then特例

##### Promise.resolve()

是成功状态Promise的一种简写形式
`new Promise(resolve => resolve('foo'));`简写为`Promise.resolve('foo');`
对于不同的参数

- 一般参数：直接向后传递
- 当Promise.resolve()接收的是Promise对象时，直接返回这个Promise对象，什么都不做
- 当resolve函数接收的是Promise对象时，后面的then会根据传递的Promise对象的状态变换决定执行哪一个回调

##### Promise.reject()

失败状态Promise的一种简写形式
`new Promise((resolve,reject) => {reject('reason');});`等价于`Promise.reject('reason');`
不管什么参数，都会原封不动地向后传递，作为后续方法的参数。

推荐在调用resolve或reject函数的时候加上return，不再执行它们后面的代码。

##### Promise.all()

Promise.all()关注多个Promise对象的状态变化
传入多个Promise实例。包装成一个新的Promise实例返回
Promise.all()的状态变化与所有传入的Promise实例对象状态有关
所有状态都变成resolved，最终的状态才会变成resolved
只要有一个变成rejected，最终的状态就立马变成rejected

##### Promise.race()

Promise.race()的状态取决于第一个完成的Promise实例对象，如果第一个完成的成功了，那最终的就成功；如果第一个完成的失败了，那最终的就失败。
##### Promise.allSettled()

Promise.allSettled()的状态与传入的Promise状态无关，永远都是成功的，它只会忠实的记录下各个Promise的表现

**Promise.all/race/allSettled的参数问题**
参数如果不是Promise数组，会将不是Promise的数组元素转变成Promise对象

```js
Promise.all([1,2,3]).then(datas => {
    console.log(datas);
});
//等价于
Promise.all([
    Promise.resolve(1),
    Promise.resolve(2),
	Promise.resolve(3),
]).then(datas => {
    console.log(datas);
});
```

不只是数组，任何可遍历的都可以作为参数。
**处理Promise.all/race/allSettled的错误**
错误既可以单独处理，也可以统一处理
一旦被处理，就不会在其他地方再处理一遍

##### 应用

- 异步加载图片

  ```js
  const loadImgAsync = url => {
      return new Promise((resolve,reject) => {
          const img = new Image();
          img.onload = () => {
              resolve(img);
          };
          img.onerror = () => {
              reject(new Error(`Could not load image at ${url}`));
          };
          img.src = url;
      });
  };
  ```

  

### ajax

```js
//1.创建一个ajax对象
var xhr = new XMLHttpRequest()
//2.配置本次的请求信息
//请求方式 GET POST
//请求地址 完整主机地址
//是否异步 默认时true表示异步请求，选填为false，表示同步请求
xhr.open('GET', 'http://localhost:8888/test/first', true);
//3.配置一个请求完成后触发的事件
//请求完整：本次请求发送出去，服务器接收到我们的请求，并且服务器返回的信息已经回到了浏览器
xhr.onload = function(){
    console.log('拿到了数据');
    //打印后端返回的信息
    console.log(xhr.responseTest);
    //将JSON数据解析
    var res = JSON.parse(xhr.responseText);
    console.log(res);
}
//4.把本次请求发送出去
xhr.send()
```

##### 请求方式

- get
  偏向获取的语义化
  参数时查询字符串
  大小有限制2KB作用
  参数位置在地址后面，就是请求地址与浏览器上面是一样的

- post
  偏向提交的语义化
  参数格式多样，但是需要特殊说明
  理论上没有限制
  参数位置在请求体内

  ```js
  //需要对传递的参数进行特殊说明
  //语法： xhr.setRequeatHeader('content-type', '你传递参数的格式')
  xhr.setRequestHeader('conten-type', 'application/x-www-form-urlencoded');
  //send后面的()就是书写请求体的位置
  xhr.send('nmae=Alex&age=18');
  ```


### 待解决的问题

- 防抖函数的工作原理

## jQuery

官网地址:https://jquery.com

##### 入口函数

- ```js
  $(function () {
      ...//此处是页面DOM加载完成的入口
  });
  ```

- ```js
  $(document).ready(function (){
      ...//此处是页面DOM加载完成的入口
  });
  ```

1. 等着DOM结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完毕，jQuery帮忙完成了封装。
2. 相当于原生js中的DOMContentLoaded。
3. 不同于原生js中的load事件是等页面文档，外部的js文件，css文件，图片加载完毕才执行内部代码。
4. 推荐使用方法1的写法，更简便

#### 对象

##### 顶级对象$

$是jQuery的别称，在代码中可以使用jQuery替代$，但一般为了方便，通常都直接使用$。
$是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用$包装成jQuery对象，就可以方便的调用jQuery的方法。

```js
jQuery(function(){
    alert('hello jQuery!');
})
$(function(){
    alert('hello jQuery!');
})
//上面的两个函数是一样的
```

##### 对象获取

用原生JS获取来的对象就是DOM对象	`var myDiv = document.querySelector('div');`
jQuery方法湖区的元素就是jQuery对象	`var myDiv2 = $('div')`
jQuery对象本质是：利用$对DOM对象包装后产生的对象（伪数组形式存储）

```js
console.dir(myDiv);
console.dir(mydiv2);
//两者返回的结果不一样
//第二个结果是个伪数组
```

jQuery对象只能使用jQuery方法，DOM对象则使用原生的JavaScirpt属性和方法
```js
//原生js隐藏元素的方法
myDiv.style.display = 'none';
//jQuery隐藏元素的方法
myDiv2.hide();
```

##### jQuery对象和DOM对象

DOM对象与jQuery对象之间是可以互相转换的。
因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装，要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。

- DOM对象转换为jQuery对象：`$(DOM对象)`
  ```js
  $('div')
  ```

- jQuery对象转换为DOM对象（两种方式）

  - ```js
    $('div')[index]	//index是索引号
    ```

  - ```js
    $('div').get(index)	//index是索引号
    ```

#### 选择器

原生JS获取元素方式很多，很杂，而且兼容情况不一致，因此jQuery给我们做了封装，使获取元素统一标准。
```js
$("选择器");//里面选择器直接写CSS选择器即可，但是要加引号
```
##### 基础选择器
| 名称       | 用法            | 描述                     |
| ---------- | --------------- | ------------------------ |
| ID选择器   | $("#id")        | 获取指定ID的元素         |
| 全选选择器 | $("*")          | 匹配所有元素             |
| 类选择器   | $(".class")     | 获取同一类标签的所有元素 |
| 标签选择器 | $("div")        | 获取同一类标签的所有元素 |
| 并集选择器 | $("div,p,li")   | 选取多个元素             |
| 交集选择器 | $("li.current") | 交集元素                 |

##### 层级选择器

| 名称       | 用法       | 描述                                                         |
| ---------- | ---------- | ------------------------------------------------------------ |
| 子代选择器 | $("ul>li") | 使用>号，获取亲儿子层级的元素；注意，并不会获取孙子层级的元素 |
| 后代选择器 | $("ul li") | 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等   |

##### 筛选选择器

| 语法       | 用法          | 描述                                                      |
| ---------- | ------------- | --------------------------------------------------------- |
| :first     | $('li:first') | 获取第一个li元素                                          |
| :last      | $('li:last')  | 获取最好一个li元素                                        |
| :eq(index) | $("li:eq(2)") | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 |
| :odd       | $("li:odd")   | 获取到的li元素中，选择索引号为奇数的元素                  |
| :even      | $("li:even")  | 获取到的li元素中，选择索引号为偶数的元素                  |

##### 筛选方法

| 语法               | 用法                           | 说明                                                   |
| ------------------ | ------------------------------ | ------------------------------------------------------ |
| parent()           | $("li").parent();              | 查找父级                                               |
| children(selector) | $("ul").children("li");        | 相当于$("ul>li")，最近一级（亲儿子）                   |
| find(selector)     | $("ul").find("li");            | 相当于$("ul li")，后代选择器，返回所有后代子元素匹配项 |
| siblings(selector) | $(".first").siblings("li");    | 查找兄弟节点，不包括自己本身                           |
| nextALL([expr])    | $(".last").nextAll()           | 查找当前元素之后所有的同辈元素                         |
| prevtAll([expr])   | $(".last").prevAll()           | 查找当前元素之前所有的同辈元素                         |
| hasClass(class)    | $("div").hasClass("protected") | 检查当前的元素是否含有某个特定的类，如果有，则返回true |
| eq(index)          | $("li").eq(2);                 | 相当于$("li:eq(2)")，index从0开始                      |
| parents(selector)  | $("li").parents();             | 返回指定祖先元素，默认返回所有父级，直到html           |
| first()            | $('li').first();               | 返回第一个匹配结果                                     |
| last()             | $('li').last();                | 返回最后一个匹配结果                                   |
| next()             | $('li').next();                | 返回匹配元素的下一个元素                               |
| prev()             | $('li').prev();                | 返回匹配元素的前一个元素                               |
|                    |                                |                                                        |

#### 样式设置

##### 设置样式

jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。
1.参数只写属性名，则是返回属性值

```js
consle.log($(this).css("width"));
//输出:200px
```

2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号。
如果单位是px则可以省略

```js
$('div').css('属性','值')
```

上面的一句话可以同时选到多个div，并通过上面一行代码实现多个div设置属性

3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号。

```js
$("div").css({
    width:400,
    height:400,
    backgroundColor: "red"
    //如果是复合属性则必须采取驼峰命名法
})
```

##### 设置类样式

作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点。
原生JS中className会覆盖元素原先里面的类名。jQuery里面类操作只是对指定类进行操作，不影响原先的类名。
1.添加类

```js
$("div").addClass("current");
```

2.移除类

```js
$("div").removeClass("current");
```

3.切换类

```js
$("div").toggleClass("current");
```

##### 盒子尺寸

| 语法                               | 用法                                                |
| ---------------------------------- | --------------------------------------------------- |
| width()/height()                   | 取得匹配元素宽度和高度值 只算width/height           |
| innerWidth()/innerHieght()         | 取得匹配元素宽度和高度值 包含padding                |
| outerWidth()/outerHeight()         | 取得匹配元素宽度和高度值 包含padding，border        |
| outerWidth(true)/outerHeight(true) | 取得匹配元素宽度和高度值 包含padding，borde，margin |

以上参数为空，则是获取响应值，返回的是数字型。
如果参数为数字，则是修改相应值。
参数可以不必写单位。
不管给元素是否隐藏，都能获取到改元素的值
不管盒子模型是什么状态（怪异盒模型），拿到的尺寸区域语义不变

##### 盒子位置

位置主要有三个：offset()，position()，scrollTop()/scrollLeft()

- offset()设置或获取元素偏移
  offset()方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系。
  该方法有2个属性left，top，offset().top用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。
  可以设置元素的偏移：offset({top:10,left:30});（返回值也是长成这样的对象）

- position()获取元素偏移
  position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。
  该方法无法修改位置。
  如果给元素设置的是right和bottom，会自动换算成left和top的值
  
- scrollTop()/scrollLeft()设置或获取元素被卷去的头部和左侧
  ```js
  $(document).scrollTop();//返回页面上面卷过去了多少
  $(document).scrollTop(100);//使页面上卷100像素
  ```

  ```js
  //带有动画的返回顶部
  $(".back").click(function(){
      //animate是对元素进行操作的，不能操作document
      $("body, html").stop.animate({
          scrollTop: 0;
      });
      //上面是正确写法，下面是错误的
      //$(document).stop().animate({//不能对documnet使用animate动画
      //	scrollTop:0;
  	//})
  })
  ```

  

#### 效果

##### 显示隐藏

- show()

  1. 语法规范
     ```js
     show([speed,[easing],[fn]])
     ```

  2. 参数
     1.参数都可以省略，会无动画直接显示。
     2.speed：三种预定速度之一的字符串（"slow"，“normal”，or “fast”）或表示动画时长的毫秒数值（如：1000）。
     3.easing：（Optional）用来指定切换效果，默认是 "swing" ，可用参数 "linear" 。
     4.fn：回调函数，在动画完成时执行的函数，每个元素执行一次。
     5.默认的动画很丑，所以一般不写参数使之无动画显示

- hide()
  1.语法规范

  ```js
  hide([speed,[easing],[fn]])
  ```

  2.参数
  略，与show函数一样

- toggle()
  1.语法规范

  ```js
  taggle([speed,[easing],[fn]])
  ```

  2.参数
  略，与show函数一样

##### 滑动

- slideDown()
- slideUp()
- slideToggle()

滑动的三个函数的语法规范和参数与显示隐藏的完全类似
```js
$(function() {
    //鼠标经过
    $(".nav>li").mouseover(function() {
        $(this).children('ul').slideDown(200);
    });
    //鼠标离开
    $(".nav>li").mouseout(function() {
        $(this).children("ul").slideUp(200);
    });
})
```



##### 淡入淡出

- fadeln()
- fadeOut()
- fadeToggle()

上面三个函数与上面的显示隐藏函数完全类似

- fadeTo()
  渐进方式调整到指定的不透明度
  语法：

  ```js
  fadeTo([[speed],opacity,[easing],[fn]])
  ```

  效果参数
  1.opacity透明度必须写，取值0~1之间。
  2.speed：三种预定速度之一的字符串（“slow”，"normal"，or "fast"）或表示动画时长的毫秒数值（如：1000）.必须写
  3.easing：（Optional）用来指定切换效果，默认是“swing”，可用参数“linear”。

  ```js
  $(function() {
      //鼠标进入的时候，其他的li标签透明度:0.5
      $(".wrap li").hover(function() {
          $(this).siblings().stop().fadeTo(400, 0.5);//注意加stop
      },function() {
          //鼠标离开，其他li透明度改为1
          $(this).siblings().stop().fadeTo(400, 1);
      })
  })
  ```

  

##### 自定义动画

- animate()
  1.语法：

  ```js
  animate(params,[speed],[easing],[fn])
  ```

  2.参数
  params:想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法。其余参数都可以省略。
  其他参数与上面的函数完全类似
  关于颜色相关的样式是不能运动的
  关于transform相关的样式是不能运动的

##### 动画队列

动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。
**停止排队**

```js
//stop()
 $(this).children("ul").stop().slideToggle();
```

1.stop()方法用于停止动画或效果。
2.注意：stop()写到动画或者效果的前面，相当于停止结束上一次的动画。
当任何一个元素，执行了stop方法之后，会立即结束当前的所有运动，目前运动到什么位置，就停留在什么位置
一般对应结束动画的时候，都是在运动开始之前

```js
// 利用结束动画书写动画函数
// 每一次触发的时候，都会把之前的动画停止下来，只执行本次最新的动画
// $('div').stop().toggle(2000)
```

finish()
对任何一个元素执行了finish方法后，会立即结束当前的所有运动，直接去到动画结束位置
该方法因为瞬间完成，会造成闪烁效果，很不好，较少使用此函数

#### 属性设置

##### 元素固有属性值

所谓元素固有属性就是元素本身自带的属性，比如`<a>`元素里面的href，比如`<input>`元素里面的type。

- 获取属性语法
  ```js
  prop("属性")
  ```

- 设置属性语法
  ```js
  prop("属性", "属性值")
  ```

示例:
```js
$(function() {
    //1.element.prop("属性名")  获取元素固有的属性值
    console.log($("a").prop("href"));
    $("a").prop("title", "我们都挺好");
    $("input").change(function() {
        console.log($(this).prop("checked"));
    });
});
```

- prop()
  可以获取和设置元素的属性
  当prop设置元素的原生属性，会直接相应在元素标签身上
  当prop设置元素自定义属性，不会直接相应在元素标签身上，会影响在元素对象身上
- removeProp()
  用来删除元素的属性的方法
  不能删除原生属性
  只能删除由prop方法设置的自定义属性
  语法：元素集合.removeProp(你要删除的属性名)

##### 元素自定义属性值

用户自己给元素添加的属性，我们称为自定义属性。比如给div添加index="1"
attr操作的所有属性都会直接出现在元素的标签身上，因此一般用于操作元素的自定义属性

- 获取属性语法
  ```js
  attr("属性")	//类似原生getAttribute()
  ```

- 设置属性语法
  ```js
  attr("属性","属性值")	//类似原生setAttribute()
  ```

示例：
```js
$(function(){
    //元素的自定义属性，我们通过attr()
    console.log($("div").attr("index"));
    $("div").attr("index", 4);
    console.log($("div").attr("data-index"));
})
```

- removeAttr()
  对元素的属性进行删除操作
  语法：元素集合.removeAttr(你要删除的属性名)

##### 数据缓存

data()方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都将被移除。

- 附加数据语法
  ```js
  data("name", "value") //向被选元素附加数据
  ```

- 获取数据语法
  ```js
  date("name") //向被选元素获取数据
  ```

示例：
```js
$(function(){
    //数据缓存 data() 这个里面的数据是存放在元素的内存里面
    $("span").data("uname", "andy");
    console.log($("span").data("uname"));
    // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型
    console.log($("div").data("index"));
})
```

##### 内容文本值

主要针对元素的内容还有表单的值操作。

- 普通元素内容html()（相当于原生innerHTML）
  `html()  //获取元素的内容`
  `html("内容")  //设置元素的内容`
  会识别并解析html的结构标记
- 普通元素文本内容text()（相当于元素innerText）
  不会识别与解析html的结构标记
- 表单的值val()（相当于原生value）
  `val("内容")  //设置元素的内容`
  用来设置表单元素的value

**该方法也可以获取H5自定义属性(data-变量名)，得到的是数字型**
示例：

```js
```

#### 元素操作

##### 遍历元素

jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作，就需要用到遍历。
```js
//这是语法1
$("div").each(function (index, domEle){ xxx; })
```

1.each()方法遍历匹配的每一个元素。主要用DOM处理。
2.里面的回调函数有2个参数：index是每个元素的索引号；demEle是每个DOM元素对象，不是jquery对象。
3.所以要想使用jquery方法，需要给这个dom元素转换位jquery对象$(domEle)
示例：

```js
$(function(){
    var sum=0;
    var arr = ["red", "green", "blue"];
    $("div").each(function(i, domEle){
        //该回调函数第一个参数一定是索引号，可以自己指定索引号的名称
        console.log(i);
        //该回调函数第二个参数一定是dom元素对象
        console.log(domEle);
        $(domEle).css("color", arr[i]);
        sum += parseInt($(domEle).text());
    });
});
```

```js
//语法2
$.each(object, function(index, element){ xxx; })
```

1.$.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象。
2.里面的函数有2个参数：index是每个元素的索引号；element是遍历出来的内容。
示例：

```js
$(function(){
	var arr = ["red", "green", "blue"];
    $.each(arr, function(i, ele){
        console.log(i);
        console.log(ele);
    });
    $.each({
        name:"andy",
        age: 18
    }, function(i, ele){
        console.log(i);
        console.log(ele);
    });
});
```

##### 创建元素

语法：`$("<li></li>");`
##### 添加元素

- 内部添加
  ```js
  element.append("内容")
  var li = $("<li>我是后来创建的li</li>");
  $("ul").append(li);
  ```

  把内容放入匹配元素内部最后面，类似原生appendChild
  ```js
  element.prepend("内容");  //内部添加并且放到内容的最后面
  $("ul").append(li);
  ```

  内部添加元素，生成之后，它们是父子关系。

- 外部添加
  ```js
  element.after("内容")  //把内容放到目标元素后面
  element.before("内容")  //把内容放入目标元素前面
  ```

  外部添加元素，生成之后，它们是兄弟关系。

##### 删除元素

```js
element.remove()  //删除匹配的元素（本身）
element.empty()  //删除匹配的元素集合中所有的子节点
element.html("")  //清空匹配的元素内容
```



#### 其他函数

##### 拷贝对象

如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend()方法
语法:

```js
$.extend([deep], target, objecrt1, [objectN])
```

1.deep：如果设为true，就是深拷贝，默认为false浅拷贝。
2.target：要拷贝的目标对象
3.object1：待拷贝到第一个对象的对象。
4.objectN：待拷贝到第N个对象的对象。
5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。
6.深拷贝，前面加true，完全克隆（拷贝的对象，而不是地址），修改目标对象不会影响被拷贝对象。

### 事件

#### 绑定事件

##### 单个事件注册

语法：
```js
element.事件(function(){})
```

```js
$("div").click(function(){事件处理程序})
```

其他事件和原生基本一致
比如mouseover,mouseout,blur,focus,change,keydown,keyup,resize,scroll等
示例：

```js
$(function(){
    //单个事件注册
    $("div").click(function(){
        $(this).css("backgroud", "purple");
    });
    $("div").mouseenter(function(){
        $(this).css("background", "skyblue");
    });
});
```

##### 事件处理函数

###### on()
方法在匹配原生上绑定一个或多个事件的事件处理函数
语法：

```js
element.on(events, [selector], fn)
```

1.events:一个或多个用空格分隔的事件类型，如“click"或"keydown"。
2.selector:元素的子元素选择器。
3.fn:回调函数 即绑定在元素身上的侦听函数。
**on()的优势1：**可以绑定多个事件，多个处理事件程序
示例:

```js
$(function(){
    //事件处理on
    $("div").on({
        mouseenter: function() {
            $(this).css("background", "skyblue");
        },
        click: function() {
            $(this).css("background", "purple");
        },
        mouseleave: function() {
            $(this).css("background", "blue");
        }
    })
    //如果还事件处理程序相同，则可以更加简单
    $("div").on("mouseenter mouesleave", function(){
        $(this).toggleClass("current");
    })
});
```

**on()的优势2**：可以事件委派操作。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。

```js
$('ul').on('click', 'li', function(){
    alert('hello world!');
});
```

在此之前有bind(),live()delegate()等方法来处理事件绑定或者事件委派，最新版本的请用on替代他们。
**on()的优势3**：动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件
示例:

```js
$(function(){
    //$("ol li").click(function(){	//该方法在新添加的元素上面工作
    //	alert(11);
	//})
    $("ol").on("click", "li", function(){
        alert(11);
    })
    var li = $("<li>我是后来创建的</li>");
    $("ol").qppend(li);
})
```

###### one()
如果有的事件只想触发一次，可以使用one()来绑定事件。
该函数使用方法和on()一样

###### hover()

hover() 鼠标事件切换

```js
hover([over],out)
```

1.over：鼠标移到元素上要触发的函数（相当于mouseenter）
2.out：鼠标移除元素要触发的函数（相当于mouseleave）
3.若只给一个函数，则这一个函数会被调用两次（等同于这一个函数填充两个空）

```js
$(function(){
    //1.事件切换 hover 就是鼠标经过和离开的复合写法
    $(".nav>li").hover(
        function(){
        	$(this).children("ul").slideDown(200);}, 
        function(){
        	$(this).children("ul").slideUp(200);}
    );
});
```

```js
$(function(){
    $(".nav>li").hover(function(){
        $(this).children("ul").slideToggle();
    });
});
```

##### 解绑事件

off()方法可以移除通过on()方法添加的事件处理程序。
```js
$("p").off();// 解绑p元素所有事件处理程序
$("p").off("click");//解绑p元素上面的点击事件 后面的foo是侦听函数名
$("ul").off("click", "li");//解绑事件委托
```


##### 自动触发事件

有些事件希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。
```js
element.click()//第一种简写形式
```

```js
element.trigger("type");//第二种自动触发模式
```

```js
$("p").on("click", function() {
    alert("hi~");
});
$("p").trigger("click");//此时自动触发点击事件，不需要鼠标点击
```

```js
element.triggerHandler(typs)//第三种自动触发模式，这个函数会不触发元素的默认行为
```

```js
$(function(){
    $("input").on("focus", function(){
        $(this).val("你好吗");
    });
    //$("input").trigger("focus");	//这个方法会在输入框中有闪烁的光标
    $("input").triggerHandler("focus");	  //这个方法不会在输入框中有闪烁的光标，但触发了focus事件，输入框中有"你好吗"
})
```

##### 事件对象

事件被触发，就会有事件对象的产生。
```js
element.on(events, [selector], function(event){})
```

阻止默认行为：event.prevemtDafault()或者return false
阻止冒泡：event.stopPropagation()

---

```js
(p*n).tpFixed(2);	//将小数格式变成固定保留2位
```

---

### ajax

因为发送ajax请求，不是操作DOM，不需要依赖选择器去获取到元素
语法：`$.aja({本次发送ajax的配置项})`
配置项：

- url：必填，表示请求地址
- method：选填，默认是GET，表示请求方式
- data：选填，默认是''，表示携带给后端的参数
- async：选填，默认是true，表示是否异步
- succsee：选填，表示请求成功的回调函数
- error：选填，表示请求失败的回调函数

示例：
```js
$.ajax({
    url:'http://localhost::8888/test/third',
    method: 'POST',
    data: {name: 'name', age: 18},
    success: function(res){
        console.log(res)
    }
})
```



#### 部分特性

##### 隐式迭代
遍历内部DOM元素（伪数组形式存储）的过程就叫做隐式迭代。
简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。

##### 链式编程

链式编程是为了节省代码量，看起来更优雅。
```js
$("button").click(function() {
    //让当前元素颜色变为红色
    $(this).css("color","red");
    //让其余的姐妹元素不变色
    $(this).siblings().css("color","");
    //上面两个语句转换为链式编程写法如下---------------------
    $(this).css("color","red").siblings().css("color","");
})
```

使用链式编程一定注意是哪个对象执行样式。
##### 多库并存

问题描述：
jQuery使用$作为标识符，随着jQuery的流行，其他js库也会用这$作为标识符，这样一起使用会引起冲突。
客观需求：
需要一个解决方案，让jQuery和其他的js库不存在冲突，可以同时存在，这就叫多库并存，
**jQuery解决方案：
1.把里面的$符号统一改为jQuery。比如jQuery("div")
2.jQuery变量规定新的名称：$.noConflict()	var xx = $.noConflict();
示例:

```js
$(function(){
    function $(ele){
        return document.querySelector(ele);
    }
    console.log($("div"));
    //1.如果$符号冲突 我们就使用 jQuery
    jQuery.each();
    //2.让jQuery释放对$控制权 让用户自己决定
    var suibian = jQuery.noConflict();
    console.log(suibian("span"));
    suibian.each();
})
```

##### jQuery插件

jQuery功能比较有限，想要更复杂的特效效果，可以借助于jQuery插件完成。
注意：这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也成为jQuery插件。
**jQuery插件常用的网站**:
jQuery插件库 http://www.jq22.com
jQuery之家 http://www.htmleaf.com
**jQUery插件使用步骤**:
1.引入相关文件。（jQuery文件和插件文件）
2.赋值相关html，css，js（调用插件）。

###### 懒加载插件

图片懒加载（图片使用延迟加载可提高网页下载速度。它也能帮助减轻服务器负载）
当我们页面滑动到可视区域，再显示图片。
我们使用jQuery插件库EasyLazyload。注意，此时的js引入文件和js调用必须写到DOM元素（图片）最后面。

###### 全屏滚动

fullpage.js
gitHub：https://github.com/alvarotrigo/fullPage.js
(已失效)中文翻译网站：http://www.dowebook.com/demo/2014/77/

###### bootstrap插件

bootstrap框架也是依赖于jQuery开发的，因此里面的js插件使用，也必须引入jQuery文件。


## 其他零散的知识

##### 相对路径

同一级路径	./
上一级路径	../

##### 颜色

语法：`<font color='#999999'>深灰色</font>`
#999 <font color='#999999'>深灰色</font>
#ddd <font color='#dddddd'>浅灰色</font>
#666 <font color='#666'>深灰色</font>
#333 <font color='#999999'>淡黑色</font>
#ccc <font color='#ccc'>银灰色</font>
#E8E8E8 <font color='#E8E8E8'>银灰色</font>
#1faf88 <font color='#1afaf88'>青绿色</font>
#0094ff <font color='#0094ff'>天蓝色</font>
#1DD1A1 <font color='#1DD1A1'>清绿色</font>
#ff7979 <font color='#ff7979'>淡西瓜红色</font>
#f7f7f7 <font color='#f7f7f7'>极淡灰</font>
transparents 透明
#b5b5b5<font color='#b5b5b5'>脏灰色</font>
#d1d1d1 <font color='#d1d1d1'>浅灰色</font>
#dedede <font color='#dedede'>浅灰色</font>
skyblue <font color='skyblue'>天蓝色</font>
lightblue<font color='lightblue'>亮蓝色</font>
#828282 <font color='#828282'>坚实灰色</font>
#262626 <font color='#262626'>亮黑色</font>
#0070ff <font color='#0070ff'>坚定蓝</font>
#ff3968 <font color='#ff3968'>新鲜红</font>
#ff246f <font color='#ff246f'>新鲜红</font>
#ff00fff <font color='#ff00ff'>紫红色</font>
#8a2be2 <font color='#8a2be2'>正宗紫</font>
#12b5ff <font color='#12b5ff'>新鲜蓝</font>
#f1f1f1 <font color='#f1f1f1'>rgba淡影子</font>
#f9f9f9f <font color='#f9f9f9'>微变白</font>
#d1e2ff <font color='#d1e2ff'>表格框</font>
#7e5e3e<font color='#7e5e3e'>烫金色</font>

